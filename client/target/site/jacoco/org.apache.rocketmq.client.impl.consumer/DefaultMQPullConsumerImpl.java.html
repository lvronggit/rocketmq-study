<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMQPullConsumerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 4.9.5-SNAPSHOT</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.impl.consumer</a> &gt; <span class="el_source">DefaultMQPullConsumerImpl.java</span></div><h1>DefaultMQPullConsumerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.impl.consumer;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import org.apache.rocketmq.client.QueryResult;
import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.consumer.DefaultMQPullConsumer;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.PullCallback;
import org.apache.rocketmq.client.consumer.PullResult;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.hook.ConsumeMessageContext;
import org.apache.rocketmq.client.hook.ConsumeMessageHook;
import org.apache.rocketmq.client.hook.FilterMessageHook;
import org.apache.rocketmq.client.impl.CommunicationMode;
import org.apache.rocketmq.client.impl.MQClientManager;
import org.apache.rocketmq.client.impl.factory.MQClientInstance;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.ServiceState;
import org.apache.rocketmq.common.UtilAll;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.filter.ExpressionType;
import org.apache.rocketmq.common.filter.FilterAPI;
import org.apache.rocketmq.common.help.FAQUrl;
import org.apache.rocketmq.common.protocol.NamespaceUtil;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageAccessor;
import org.apache.rocketmq.common.message.MessageConst;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.body.ConsumerRunningInfo;
import org.apache.rocketmq.common.protocol.heartbeat.ConsumeType;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;
import org.apache.rocketmq.common.sysflag.PullSysFlag;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.apache.rocketmq.remoting.exception.RemotingException;

/**
 * This class will be removed in 2022, and a better implementation {@link DefaultLitePullConsumerImpl} is recommend to use
 * in the scenario of actively pulling messages.
 */
@Deprecated
public class DefaultMQPullConsumerImpl implements MQConsumerInner {
<span class="nc" id="L75">    private final InternalLogger log = ClientLogger.getLog();</span>
    private final DefaultMQPullConsumer defaultMQPullConsumer;
<span class="nc" id="L77">    private final long consumerStartTimestamp = System.currentTimeMillis();</span>
    private final RPCHook rpcHook;
<span class="nc" id="L79">    private final ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = new ArrayList&lt;ConsumeMessageHook&gt;();</span>
<span class="nc" id="L80">    private final ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = new ArrayList&lt;FilterMessageHook&gt;();</span>
<span class="nc" id="L81">    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;</span>
    protected MQClientInstance mQClientFactory;
    private PullAPIWrapper pullAPIWrapper;
    private OffsetStore offsetStore;
<span class="nc" id="L85">    private RebalanceImpl rebalanceImpl = new RebalancePullImpl(this);</span>

<span class="nc" id="L87">    public DefaultMQPullConsumerImpl(final DefaultMQPullConsumer defaultMQPullConsumer, final RPCHook rpcHook) {</span>
<span class="nc" id="L88">        this.defaultMQPullConsumer = defaultMQPullConsumer;</span>
<span class="nc" id="L89">        this.rpcHook = rpcHook;</span>
<span class="nc" id="L90">    }</span>

    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {
<span class="nc" id="L93">        this.consumeMessageHookList.add(hook);</span>
<span class="nc" id="L94">        log.info(&quot;register consumeMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L95">    }</span>

    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
<span class="nc" id="L98">        createTopic(key, newTopic, queueNum, 0);</span>
<span class="nc" id="L99">    }</span>

    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
<span class="nc" id="L102">        this.isRunning();</span>
<span class="nc" id="L103">        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag);</span>
<span class="nc" id="L104">    }</span>

    private void isRunning() throws MQClientException {
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (this.serviceState != ServiceState.RUNNING) {</span>
<span class="nc" id="L108">            throw new MQClientException(&quot;The consumer is not in running status, &quot;</span>
                + this.serviceState
<span class="nc" id="L110">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                null);
        }
<span class="nc" id="L113">    }</span>

    public long fetchConsumeOffset(MessageQueue mq, boolean fromStore) throws MQClientException {
<span class="nc" id="L116">        this.isRunning();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        return this.offsetStore.readOffset(mq, fromStore ? ReadOffsetType.READ_FROM_STORE : ReadOffsetType.MEMORY_FIRST_THEN_STORE);</span>
    }

    public Set&lt;MessageQueue&gt; fetchMessageQueuesInBalance(String topic) throws MQClientException {
<span class="nc" id="L121">        this.isRunning();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (null == topic) {</span>
<span class="nc" id="L123">            throw new IllegalArgumentException(&quot;topic is null&quot;);</span>
        }

<span class="nc" id="L126">        ConcurrentMap&lt;MessageQueue, ProcessQueue&gt; mqTable = this.rebalanceImpl.getProcessQueueTable();</span>
<span class="nc" id="L127">        Set&lt;MessageQueue&gt; mqResult = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        for (MessageQueue mq : mqTable.keySet()) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            if (mq.getTopic().equals(topic)) {</span>
<span class="nc" id="L130">                mqResult.add(mq);</span>
            }
<span class="nc" id="L132">        }</span>

<span class="nc" id="L134">        return parseSubscribeMessageQueues(mqResult);</span>
    }

    public List&lt;MessageQueue&gt; fetchPublishMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L138">        this.isRunning();</span>
<span class="nc" id="L139">        return this.mQClientFactory.getMQAdminImpl().fetchPublishMessageQueues(topic);</span>
    }

    public Set&lt;MessageQueue&gt; fetchSubscribeMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L143">        this.isRunning();</span>
        // check if has info in memory, otherwise invoke api.
<span class="nc" id="L145">        Set&lt;MessageQueue&gt; result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L147">            result = this.mQClientFactory.getMQAdminImpl().fetchSubscribeMessageQueues(topic);</span>
        }

<span class="nc" id="L150">        return parseSubscribeMessageQueues(result);</span>
    }

    public Set&lt;MessageQueue&gt; parseSubscribeMessageQueues(Set&lt;MessageQueue&gt; queueSet) {
<span class="nc" id="L154">        Set&lt;MessageQueue&gt; resultQueues = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        for (MessageQueue messageQueue : queueSet) {</span>
<span class="nc" id="L156">            String userTopic = NamespaceUtil.withoutNamespace(messageQueue.getTopic(),</span>
<span class="nc" id="L157">                this.defaultMQPullConsumer.getNamespace());</span>
<span class="nc" id="L158">            resultQueues.add(new MessageQueue(userTopic, messageQueue.getBrokerName(), messageQueue.getQueueId()));</span>
<span class="nc" id="L159">        }</span>
<span class="nc" id="L160">        return resultQueues;</span>
    }

    public long earliestMsgStoreTime(MessageQueue mq) throws MQClientException {
<span class="nc" id="L164">        this.isRunning();</span>
<span class="nc" id="L165">        return this.mQClientFactory.getMQAdminImpl().earliestMsgStoreTime(mq);</span>
    }

    public long maxOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L169">        this.isRunning();</span>
<span class="nc" id="L170">        return this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span>
    }

    public long minOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L174">        this.isRunning();</span>
<span class="nc" id="L175">        return this.mQClientFactory.getMQAdminImpl().minOffset(mq);</span>
    }

    public PullResult pull(MessageQueue mq, String subExpression, long offset, int maxNums)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L180">        return pull(mq, subExpression, offset, maxNums, this.defaultMQPullConsumer.getConsumerPullTimeoutMillis());</span>
    }

    public PullResult pull(MessageQueue mq, String subExpression, long offset, int maxNums, long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L185">        SubscriptionData subscriptionData = getSubscriptionData(mq, subExpression);</span>
<span class="nc" id="L186">        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, false, timeout);</span>
    }

    public PullResult pull(MessageQueue mq, MessageSelector messageSelector, long offset, int maxNums)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L191">        return pull(mq, messageSelector, offset, maxNums, this.defaultMQPullConsumer.getConsumerPullTimeoutMillis());</span>
    }

    public PullResult pull(MessageQueue mq, MessageSelector messageSelector, long offset, int maxNums, long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L196">        SubscriptionData subscriptionData = getSubscriptionData(mq, messageSelector);</span>
<span class="nc" id="L197">        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, false, timeout);</span>
    }

    private SubscriptionData getSubscriptionData(MessageQueue mq, String subExpression)
        throws MQClientException {

<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (null == mq) {</span>
<span class="nc" id="L204">            throw new MQClientException(&quot;mq is null&quot;, null);</span>
        }

        try {
<span class="nc" id="L208">            return FilterAPI.buildSubscriptionData(mq.getTopic(), subExpression);</span>
<span class="nc" id="L209">        } catch (Exception e) {</span>
<span class="nc" id="L210">            throw new MQClientException(&quot;parse subscription error&quot;, e);</span>
        }
    }

    private SubscriptionData getSubscriptionData(MessageQueue mq, MessageSelector messageSelector)
        throws MQClientException {

<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (null == mq) {</span>
<span class="nc" id="L218">            throw new MQClientException(&quot;mq is null&quot;, null);</span>
        }

        try {
<span class="nc" id="L222">            return FilterAPI.build(mq.getTopic(),</span>
<span class="nc" id="L223">                messageSelector.getExpression(), messageSelector.getExpressionType());</span>
<span class="nc" id="L224">        } catch (Exception e) {</span>
<span class="nc" id="L225">            throw new MQClientException(&quot;parse subscription error&quot;, e);</span>
        }
    }

    private PullResult pullSyncImpl(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums, boolean block,
        long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L232">        this.isRunning();</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (null == mq) {</span>
<span class="nc" id="L235">            throw new MQClientException(&quot;mq is null&quot;, null);</span>
        }

<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (offset &lt; 0) {</span>
<span class="nc" id="L239">            throw new MQClientException(&quot;offset &lt; 0&quot;, null);</span>
        }

<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (maxNums &lt;= 0) {</span>
<span class="nc" id="L243">            throw new MQClientException(&quot;maxNums &lt;= 0&quot;, null);</span>
        }

<span class="nc" id="L246">        this.subscriptionAutomatically(mq.getTopic());</span>

<span class="nc" id="L248">        int sysFlag = PullSysFlag.buildSysFlag(false, block, true, false);</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">        long timeoutMillis = block ? this.defaultMQPullConsumer.getConsumerTimeoutMillisWhenSuspend() : timeout;</span>

<span class="nc" id="L252">        boolean isTagType = ExpressionType.isTagType(subscriptionData.getExpressionType());</span>
<span class="nc" id="L253">        PullResult pullResult = this.pullAPIWrapper.pullKernelImpl(</span>
            mq,
<span class="nc" id="L255">            subscriptionData.getSubString(),</span>
<span class="nc" id="L256">            subscriptionData.getExpressionType(),</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            isTagType ? 0L : subscriptionData.getSubVersion(),</span>
            offset,
            maxNums,
            sysFlag,
            0,
<span class="nc" id="L262">            this.defaultMQPullConsumer.getBrokerSuspendMaxTimeMillis(),</span>
            timeoutMillis,
            CommunicationMode.SYNC,
            null
        );
<span class="nc" id="L267">        this.pullAPIWrapper.processPullResult(mq, pullResult, subscriptionData);</span>
        //If namespace is not null , reset Topic without namespace.
<span class="nc" id="L269">        this.resetTopic(pullResult.getMsgFoundList());</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc" id="L271">            ConsumeMessageContext consumeMessageContext = null;</span>
<span class="nc" id="L272">            consumeMessageContext = new ConsumeMessageContext();</span>
<span class="nc" id="L273">            consumeMessageContext.setNamespace(defaultMQPullConsumer.getNamespace());</span>
<span class="nc" id="L274">            consumeMessageContext.setConsumerGroup(this.groupName());</span>
<span class="nc" id="L275">            consumeMessageContext.setMq(mq);</span>
<span class="nc" id="L276">            consumeMessageContext.setMsgList(pullResult.getMsgFoundList());</span>
<span class="nc" id="L277">            consumeMessageContext.setSuccess(false);</span>
<span class="nc" id="L278">            this.executeHookBefore(consumeMessageContext);</span>
<span class="nc" id="L279">            consumeMessageContext.setStatus(ConsumeConcurrentlyStatus.CONSUME_SUCCESS.toString());</span>
<span class="nc" id="L280">            consumeMessageContext.setSuccess(true);</span>
<span class="nc" id="L281">            this.executeHookAfter(consumeMessageContext);</span>
        }
<span class="nc" id="L283">        return pullResult;</span>
    }

    public void resetTopic(List&lt;MessageExt&gt; msgList) {
<span class="nc bnc" id="L287" title="All 4 branches missed.">        if (null == msgList || msgList.size() == 0) {</span>
<span class="nc" id="L288">            return;</span>
        }

        //If namespace not null , reset Topic without namespace.
<span class="nc bnc" id="L292" title="All 2 branches missed.">        for (MessageExt messageExt : msgList) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (null != this.getDefaultMQPullConsumer().getNamespace()) {</span>
<span class="nc" id="L294">                messageExt.setTopic(NamespaceUtil.withoutNamespace(messageExt.getTopic(), this.defaultMQPullConsumer.getNamespace()));</span>
            }
<span class="nc" id="L296">        }</span>

<span class="nc" id="L298">    }</span>

    public void subscriptionAutomatically(final String topic) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (!this.rebalanceImpl.getSubscriptionInner().containsKey(topic)) {</span>
            try {
<span class="nc" id="L303">                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L304">                this.rebalanceImpl.subscriptionInner.putIfAbsent(topic, subscriptionData);</span>
<span class="nc" id="L305">            } catch (Exception ignore) {</span>
<span class="nc" id="L306">            }</span>
        }
<span class="nc" id="L308">    }</span>

    public void unsubscribe(String topic) {
<span class="nc" id="L311">        this.rebalanceImpl.getSubscriptionInner().remove(topic);</span>
<span class="nc" id="L312">    }</span>

    @Override
    public String groupName() {
<span class="nc" id="L316">        return this.defaultMQPullConsumer.getConsumerGroup();</span>
    }

    public void executeHookBefore(final ConsumeMessageContext context) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L323">                    hook.consumeMessageBefore(context);</span>
<span class="nc" id="L324">                } catch (Throwable ignored) {</span>
<span class="nc" id="L325">                }</span>
<span class="nc" id="L326">            }</span>
        }
<span class="nc" id="L328">    }</span>

    public void executeHookAfter(final ConsumeMessageContext context) {
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L334">                    hook.consumeMessageAfter(context);</span>
<span class="nc" id="L335">                } catch (Throwable ignored) {</span>
<span class="nc" id="L336">                }</span>
<span class="nc" id="L337">            }</span>
        }
<span class="nc" id="L339">    }</span>

    @Override
    public MessageModel messageModel() {
<span class="nc" id="L343">        return this.defaultMQPullConsumer.getMessageModel();</span>
    }

    @Override
    public ConsumeType consumeType() {
<span class="nc" id="L348">        return ConsumeType.CONSUME_ACTIVELY;</span>
    }

    @Override
    public ConsumeFromWhere consumeFromWhere() {
<span class="nc" id="L353">        return ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span>
    }

    @Override
    public Set&lt;SubscriptionData&gt; subscriptions() {
<span class="nc" id="L358">        Set&lt;SubscriptionData&gt; result = new HashSet&lt;SubscriptionData&gt;();</span>

<span class="nc" id="L360">        Set&lt;String&gt; topics = this.defaultMQPullConsumer.getRegisterTopics();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (topics != null) {</span>
<span class="nc" id="L362">            synchronized (topics) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                for (String t : topics) {</span>
<span class="nc" id="L364">                    SubscriptionData ms = null;</span>
                    try {
<span class="nc" id="L366">                        ms = FilterAPI.buildSubscriptionData(t, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L367">                    } catch (Exception e) {</span>
<span class="nc" id="L368">                        log.error(&quot;parse subscription error&quot;, e);</span>
<span class="nc" id="L369">                    }</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    if (ms != null) {</span>
<span class="nc" id="L371">                        ms.setSubVersion(0L);</span>
<span class="nc" id="L372">                        result.add(ms);</span>
                    }
<span class="nc" id="L374">                }</span>
<span class="nc" id="L375">            }</span>
        }

<span class="nc" id="L378">        return result;</span>
    }

    @Override
    public void doRebalance() {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (this.rebalanceImpl != null) {</span>
<span class="nc" id="L384">            this.rebalanceImpl.doRebalance(false);</span>
        }
<span class="nc" id="L386">    }</span>

    @Override
    public void persistConsumerOffset() {
        try {
<span class="nc" id="L391">            this.isRunning();</span>
<span class="nc" id="L392">            Set&lt;MessageQueue&gt; mqs = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc" id="L393">            Set&lt;MessageQueue&gt; allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();</span>
<span class="nc" id="L394">            mqs.addAll(allocateMq);</span>
<span class="nc" id="L395">            this.offsetStore.persistAll(mqs);</span>
<span class="nc" id="L396">        } catch (Exception e) {</span>
<span class="nc" id="L397">            log.error(&quot;group: &quot; + this.defaultMQPullConsumer.getConsumerGroup() + &quot; persistConsumerOffset exception&quot;, e);</span>
<span class="nc" id="L398">        }</span>
<span class="nc" id="L399">    }</span>

    @Override
    public void updateTopicSubscribeInfo(String topic, Set&lt;MessageQueue&gt; info) {
<span class="nc" id="L403">        Map&lt;String, SubscriptionData&gt; subTable = this.rebalanceImpl.getSubscriptionInner();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc" id="L406">                this.rebalanceImpl.getTopicSubscribeInfoTable().put(topic, info);</span>
            }
        }
<span class="nc" id="L409">    }</span>

    @Override
    public boolean isSubscribeTopicNeedUpdate(String topic) {
<span class="nc" id="L413">        Map&lt;String, SubscriptionData&gt; subTable = this.rebalanceImpl.getSubscriptionInner();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);</span>
            }
        }

<span class="nc" id="L420">        return false;</span>
    }

    @Override
    public boolean isUnitMode() {
<span class="nc" id="L425">        return this.defaultMQPullConsumer.isUnitMode();</span>
    }

    @Override
    public ConsumerRunningInfo consumerRunningInfo() {
<span class="nc" id="L430">        ConsumerRunningInfo info = new ConsumerRunningInfo();</span>

<span class="nc" id="L432">        Properties prop = MixAll.object2Properties(this.defaultMQPullConsumer);</span>
<span class="nc" id="L433">        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));</span>
<span class="nc" id="L434">        info.setProperties(prop);</span>

<span class="nc" id="L436">        info.getSubscriptionSet().addAll(this.subscriptions());</span>
<span class="nc" id="L437">        return info;</span>
    }

    public void pull(MessageQueue mq, String subExpression, long offset, int maxNums, PullCallback pullCallback)
        throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L442">        pull(mq, subExpression, offset, maxNums, pullCallback, this.defaultMQPullConsumer.getConsumerPullTimeoutMillis());</span>
<span class="nc" id="L443">    }</span>

    public void pull(MessageQueue mq, String subExpression, long offset, int maxNums, PullCallback pullCallback,
        long timeout)
        throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L448">        SubscriptionData subscriptionData = getSubscriptionData(mq, subExpression);</span>
<span class="nc" id="L449">        this.pullAsyncImpl(mq, subscriptionData, offset, maxNums, pullCallback, false, timeout);</span>
<span class="nc" id="L450">    }</span>

    public void pull(MessageQueue mq, MessageSelector messageSelector, long offset, int maxNums,
        PullCallback pullCallback)
        throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L455">        pull(mq, messageSelector, offset, maxNums, pullCallback, this.defaultMQPullConsumer.getConsumerPullTimeoutMillis());</span>
<span class="nc" id="L456">    }</span>

    public void pull(MessageQueue mq, MessageSelector messageSelector, long offset, int maxNums,
        PullCallback pullCallback,
        long timeout)
        throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L462">        SubscriptionData subscriptionData = getSubscriptionData(mq, messageSelector);</span>
<span class="nc" id="L463">        this.pullAsyncImpl(mq, subscriptionData, offset, maxNums, pullCallback, false, timeout);</span>
<span class="nc" id="L464">    }</span>

    private void pullAsyncImpl(
        final MessageQueue mq,
        final SubscriptionData subscriptionData,
        final long offset,
        final int maxNums,
        final PullCallback pullCallback,
        final boolean block,
        final long timeout) throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L474">        this.isRunning();</span>

<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (null == mq) {</span>
<span class="nc" id="L477">            throw new MQClientException(&quot;mq is null&quot;, null);</span>
        }

<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (offset &lt; 0) {</span>
<span class="nc" id="L481">            throw new MQClientException(&quot;offset &lt; 0&quot;, null);</span>
        }

<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (maxNums &lt;= 0) {</span>
<span class="nc" id="L485">            throw new MQClientException(&quot;maxNums &lt;= 0&quot;, null);</span>
        }

<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (null == pullCallback) {</span>
<span class="nc" id="L489">            throw new MQClientException(&quot;pullCallback is null&quot;, null);</span>
        }

<span class="nc" id="L492">        this.subscriptionAutomatically(mq.getTopic());</span>

        try {
<span class="nc" id="L495">            int sysFlag = PullSysFlag.buildSysFlag(false, block, true, false);</span>

<span class="nc bnc" id="L497" title="All 2 branches missed.">            long timeoutMillis = block ? this.defaultMQPullConsumer.getConsumerTimeoutMillisWhenSuspend() : timeout;</span>

<span class="nc" id="L499">            boolean isTagType = ExpressionType.isTagType(subscriptionData.getExpressionType());</span>
<span class="nc" id="L500">            this.pullAPIWrapper.pullKernelImpl(</span>
                mq,
<span class="nc" id="L502">                subscriptionData.getSubString(),</span>
<span class="nc" id="L503">                subscriptionData.getExpressionType(),</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                isTagType ? 0L : subscriptionData.getSubVersion(),</span>
                offset,
                maxNums,
                sysFlag,
                0,
<span class="nc" id="L509">                this.defaultMQPullConsumer.getBrokerSuspendMaxTimeMillis(),</span>
                timeoutMillis,
                CommunicationMode.ASYNC,
<span class="nc" id="L512">                new PullCallback() {</span>

                    @Override
                    public void onSuccess(PullResult pullResult) {
<span class="nc" id="L516">                        PullResult userPullResult = DefaultMQPullConsumerImpl.this.pullAPIWrapper.processPullResult(mq, pullResult, subscriptionData);</span>
<span class="nc" id="L517">                        resetTopic(userPullResult.getMsgFoundList());</span>
<span class="nc" id="L518">                        pullCallback.onSuccess(userPullResult);</span>
<span class="nc" id="L519">                    }</span>

                    @Override
                    public void onException(Throwable e) {
<span class="nc" id="L523">                        pullCallback.onException(e);</span>
<span class="nc" id="L524">                    }</span>
                });
<span class="nc" id="L526">        } catch (MQBrokerException e) {</span>
<span class="nc" id="L527">            throw new MQClientException(&quot;pullAsync unknow exception&quot;, e);</span>
<span class="nc" id="L528">        }</span>
<span class="nc" id="L529">    }</span>

    public PullResult pullBlockIfNotFound(MessageQueue mq, String subExpression, long offset, int maxNums)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L533">        SubscriptionData subscriptionData = getSubscriptionData(mq, subExpression);</span>
<span class="nc" id="L534">        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, true, this.getDefaultMQPullConsumer().getConsumerPullTimeoutMillis());</span>
    }

    public DefaultMQPullConsumer getDefaultMQPullConsumer() {
<span class="nc" id="L538">        return defaultMQPullConsumer;</span>
    }

    public void pullBlockIfNotFound(MessageQueue mq, String subExpression, long offset, int maxNums,
        PullCallback pullCallback)
        throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L544">        SubscriptionData subscriptionData = getSubscriptionData(mq, subExpression);</span>
<span class="nc" id="L545">        this.pullAsyncImpl(mq, subscriptionData, offset, maxNums, pullCallback, true,</span>
<span class="nc" id="L546">            this.getDefaultMQPullConsumer().getConsumerPullTimeoutMillis());</span>
<span class="nc" id="L547">    }</span>

    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
        throws MQClientException, InterruptedException {
<span class="nc" id="L551">        this.isRunning();</span>
<span class="nc" id="L552">        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);</span>
    }

    public MessageExt queryMessageByUniqKey(String topic, String uniqKey)
        throws MQClientException, InterruptedException {
<span class="nc" id="L557">        this.isRunning();</span>
<span class="nc" id="L558">        return this.mQClientFactory.getMQAdminImpl().queryMessageByUniqKey(topic, uniqKey);</span>
    }

    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="nc" id="L562">        this.isRunning();</span>
<span class="nc" id="L563">        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span>
    }

    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L568">        sendMessageBack(msg, delayLevel, brokerName, this.defaultMQPullConsumer.getConsumerGroup());</span>
<span class="nc" id="L569">    }</span>

    public void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,
        MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L573">        this.offsetStore.updateConsumeOffsetToBroker(mq, offset, isOneway);</span>
<span class="nc" id="L574">    }</span>

    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName, String consumerGroup)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
        try {
<span class="nc bnc" id="L579" title="All 2 branches missed.">            String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)</span>
<span class="nc" id="L580">                : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span>

<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (UtilAll.isBlank(consumerGroup)) {</span>
<span class="nc" id="L583">                consumerGroup = this.defaultMQPullConsumer.getConsumerGroup();</span>
            }

<span class="nc" id="L586">            this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, brokerName, msg,</span>
<span class="nc" id="L587">                consumerGroup, delayLevel, 3000, this.defaultMQPullConsumer.getMaxReconsumeTimes());</span>
<span class="nc" id="L588">        } catch (Exception e) {</span>
<span class="nc" id="L589">            log.error(&quot;sendMessageBack Exception, &quot; + this.defaultMQPullConsumer.getConsumerGroup(), e);</span>

<span class="nc" id="L591">            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPullConsumer.getConsumerGroup()), msg.getBody());</span>
<span class="nc" id="L592">            String originMsgId = MessageAccessor.getOriginMessageId(msg);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span>
<span class="nc" id="L594">            newMsg.setFlag(msg.getFlag());</span>
<span class="nc" id="L595">            MessageAccessor.setProperties(newMsg, msg.getProperties());</span>
<span class="nc" id="L596">            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span>
<span class="nc" id="L597">            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));</span>
<span class="nc" id="L598">            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(this.defaultMQPullConsumer.getMaxReconsumeTimes()));</span>
<span class="nc" id="L599">            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());</span>
<span class="nc" id="L600">            this.mQClientFactory.getDefaultMQProducer().send(newMsg);</span>
        } finally {
<span class="nc" id="L602">            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPullConsumer.getNamespace()));</span>
        }
<span class="nc" id="L604">    }</span>

    public synchronized void shutdown() {
<span class="nc bnc" id="L607" title="All 4 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L609">                break;</span>
            case RUNNING:
<span class="nc" id="L611">                this.persistConsumerOffset();</span>
<span class="nc" id="L612">                this.mQClientFactory.unregisterConsumer(this.defaultMQPullConsumer.getConsumerGroup());</span>
<span class="nc" id="L613">                this.mQClientFactory.shutdown();</span>
<span class="nc" id="L614">                log.info(&quot;the consumer [{}] shutdown OK&quot;, this.defaultMQPullConsumer.getConsumerGroup());</span>
<span class="nc" id="L615">                this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span>
<span class="nc" id="L616">                break;</span>
            case SHUTDOWN_ALREADY:
<span class="nc" id="L618">                break;</span>
            default:
                break;
        }
<span class="nc" id="L622">    }</span>

    public synchronized void start() throws MQClientException {
<span class="nc bnc" id="L625" title="All 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L627">                this.serviceState = ServiceState.START_FAILED;</span>

<span class="nc" id="L629">                this.checkConfig();</span>

<span class="nc" id="L631">                this.copySubscription();</span>

<span class="nc bnc" id="L633" title="All 2 branches missed.">                if (this.defaultMQPullConsumer.getMessageModel() == MessageModel.CLUSTERING) {</span>
<span class="nc" id="L634">                    this.defaultMQPullConsumer.changeInstanceNameToPID();</span>
                }

<span class="nc" id="L637">                this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPullConsumer, this.rpcHook);</span>

<span class="nc" id="L639">                this.rebalanceImpl.setConsumerGroup(this.defaultMQPullConsumer.getConsumerGroup());</span>
<span class="nc" id="L640">                this.rebalanceImpl.setMessageModel(this.defaultMQPullConsumer.getMessageModel());</span>
<span class="nc" id="L641">                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPullConsumer.getAllocateMessageQueueStrategy());</span>
<span class="nc" id="L642">                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span>

<span class="nc" id="L644">                this.pullAPIWrapper = new PullAPIWrapper(</span>
                    mQClientFactory,
<span class="nc" id="L646">                    this.defaultMQPullConsumer.getConsumerGroup(), isUnitMode());</span>
<span class="nc" id="L647">                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span>

<span class="nc bnc" id="L649" title="All 2 branches missed.">                if (this.defaultMQPullConsumer.getOffsetStore() != null) {</span>
<span class="nc" id="L650">                    this.offsetStore = this.defaultMQPullConsumer.getOffsetStore();</span>
                } else {
<span class="nc bnc" id="L652" title="All 3 branches missed.">                    switch (this.defaultMQPullConsumer.getMessageModel()) {</span>
                        case BROADCASTING:
<span class="nc" id="L654">                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPullConsumer.getConsumerGroup());</span>
<span class="nc" id="L655">                            break;</span>
                        case CLUSTERING:
<span class="nc" id="L657">                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPullConsumer.getConsumerGroup());</span>
<span class="nc" id="L658">                            break;</span>
                        default:
                            break;
                    }
<span class="nc" id="L662">                    this.defaultMQPullConsumer.setOffsetStore(this.offsetStore);</span>
                }

<span class="nc" id="L665">                this.offsetStore.load();</span>

<span class="nc" id="L667">                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPullConsumer.getConsumerGroup(), this);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                if (!registerOK) {</span>
<span class="nc" id="L669">                    this.serviceState = ServiceState.CREATE_JUST;</span>

<span class="nc" id="L671">                    throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPullConsumer.getConsumerGroup()</span>
<span class="nc" id="L672">                        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span>
                        null);
                }

<span class="nc" id="L676">                mQClientFactory.start();</span>
<span class="nc" id="L677">                log.info(&quot;the consumer [{}] start OK&quot;, this.defaultMQPullConsumer.getConsumerGroup());</span>
<span class="nc" id="L678">                this.serviceState = ServiceState.RUNNING;</span>
<span class="nc" id="L679">                break;</span>
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
<span class="nc" id="L683">                throw new MQClientException(&quot;The PullConsumer service state not OK, maybe started once, &quot;</span>
                    + this.serviceState
<span class="nc" id="L685">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                    null);
            default:
                break;
        }

<span class="nc" id="L691">    }</span>

    private void checkConfig() throws MQClientException {
        // check consumerGroup
<span class="nc" id="L695">        Validators.checkGroup(this.defaultMQPullConsumer.getConsumerGroup());</span>

        // consumerGroup
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (null == this.defaultMQPullConsumer.getConsumerGroup()) {</span>
<span class="nc" id="L699">            throw new MQClientException(</span>
                &quot;consumerGroup is null&quot;
<span class="nc" id="L701">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumerGroup
<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (this.defaultMQPullConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {</span>
<span class="nc" id="L707">            throw new MQClientException(</span>
                &quot;consumerGroup can not equal &quot;
                    + MixAll.DEFAULT_CONSUMER_GROUP
                    + &quot;, please specify another one.&quot;
<span class="nc" id="L711">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // messageModel
<span class="nc bnc" id="L716" title="All 2 branches missed.">        if (null == this.defaultMQPullConsumer.getMessageModel()) {</span>
<span class="nc" id="L717">            throw new MQClientException(</span>
                &quot;messageModel is null&quot;
<span class="nc" id="L719">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // allocateMessageQueueStrategy
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (null == this.defaultMQPullConsumer.getAllocateMessageQueueStrategy()) {</span>
<span class="nc" id="L725">            throw new MQClientException(</span>
                &quot;allocateMessageQueueStrategy is null&quot;
<span class="nc" id="L727">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // allocateMessageQueueStrategy
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (this.defaultMQPullConsumer.getConsumerTimeoutMillisWhenSuspend() &lt; this.defaultMQPullConsumer.getBrokerSuspendMaxTimeMillis()) {</span>
<span class="nc" id="L733">            throw new MQClientException(</span>
                &quot;Long polling mode, the consumer consumerTimeoutMillisWhenSuspend must greater than brokerSuspendMaxTimeMillis&quot;
<span class="nc" id="L735">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }
<span class="nc" id="L738">    }</span>

    private void copySubscription() throws MQClientException {
        try {
<span class="nc" id="L742">            Set&lt;String&gt; registerTopics = this.defaultMQPullConsumer.getRegisterTopics();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            if (registerTopics != null) {</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">                for (final String topic : registerTopics) {</span>
<span class="nc" id="L745">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L746">                    this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L747">                }</span>
            }
<span class="nc" id="L749">        } catch (Exception e) {</span>
<span class="nc" id="L750">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L751">        }</span>
<span class="nc" id="L752">    }</span>

    public void updateConsumeOffset(MessageQueue mq, long offset) throws MQClientException {
<span class="nc" id="L755">        this.isRunning();</span>
<span class="nc" id="L756">        this.offsetStore.updateOffset(mq, offset, false);</span>
<span class="nc" id="L757">    }</span>

    public MessageExt viewMessage(String msgId)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L761">        this.isRunning();</span>
<span class="nc" id="L762">        return this.mQClientFactory.getMQAdminImpl().viewMessage(msgId);</span>
    }

    public void registerFilterMessageHook(final FilterMessageHook hook) {
<span class="nc" id="L766">        this.filterMessageHookList.add(hook);</span>
<span class="nc" id="L767">        log.info(&quot;register FilterMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L768">    }</span>

    public OffsetStore getOffsetStore() {
<span class="nc" id="L771">        return offsetStore;</span>
    }

    public void setOffsetStore(OffsetStore offsetStore) {
<span class="nc" id="L775">        this.offsetStore = offsetStore;</span>
<span class="nc" id="L776">    }</span>

    public PullAPIWrapper getPullAPIWrapper() {
<span class="nc" id="L779">        return pullAPIWrapper;</span>
    }

    public void setPullAPIWrapper(PullAPIWrapper pullAPIWrapper) {
<span class="nc" id="L783">        this.pullAPIWrapper = pullAPIWrapper;</span>
<span class="nc" id="L784">    }</span>

    public ServiceState getServiceState() {
<span class="nc" id="L787">        return serviceState;</span>
    }

    //Don't use this deprecated setter, which will be removed soon.
    @Deprecated
    public void setServiceState(ServiceState serviceState) {
<span class="nc" id="L793">        this.serviceState = serviceState;</span>
<span class="nc" id="L794">    }</span>

    public long getConsumerStartTimestamp() {
<span class="nc" id="L797">        return consumerStartTimestamp;</span>
    }

    public RebalanceImpl getRebalanceImpl() {
<span class="nc" id="L801">        return rebalanceImpl;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>