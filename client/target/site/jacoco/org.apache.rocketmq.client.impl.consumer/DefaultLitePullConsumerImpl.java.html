<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultLitePullConsumerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 4.9.5-SNAPSHOT</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.impl.consumer</a> &gt; <span class="el_source">DefaultLitePullConsumerImpl.java</span></div><h1>DefaultLitePullConsumerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.impl.consumer;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;
import org.apache.rocketmq.client.consumer.MessageQueueListener;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.PullResult;
import org.apache.rocketmq.client.consumer.TopicMessageQueueChangeListener;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.hook.ConsumeMessageContext;
import org.apache.rocketmq.client.hook.ConsumeMessageHook;
import org.apache.rocketmq.client.hook.FilterMessageHook;
import org.apache.rocketmq.client.impl.CommunicationMode;
import org.apache.rocketmq.client.impl.MQClientManager;
import org.apache.rocketmq.client.impl.factory.MQClientInstance;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.ServiceState;
import org.apache.rocketmq.common.ThreadFactoryImpl;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.filter.ExpressionType;
import org.apache.rocketmq.common.filter.FilterAPI;
import org.apache.rocketmq.common.help.FAQUrl;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.NamespaceUtil;
import org.apache.rocketmq.common.protocol.body.ConsumerRunningInfo;
import org.apache.rocketmq.common.protocol.heartbeat.ConsumeType;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;
import org.apache.rocketmq.common.sysflag.PullSysFlag;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.exception.RemotingException;

public class DefaultLitePullConsumerImpl implements MQConsumerInner {

<span class="nc" id="L79">    private final InternalLogger log = ClientLogger.getLog();</span>

<span class="nc" id="L81">    private final long consumerStartTimestamp = System.currentTimeMillis();</span>

    private final RPCHook rpcHook;

<span class="nc" id="L85">    private final ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = new ArrayList&lt;FilterMessageHook&gt;();</span>

<span class="nc" id="L87">    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;</span>

    protected MQClientInstance mQClientFactory;

    private PullAPIWrapper pullAPIWrapper;

    private OffsetStore offsetStore;

<span class="nc" id="L95">    private RebalanceImpl rebalanceImpl = new RebalanceLitePullImpl(this);</span>

<span class="nc" id="L97">    private enum SubscriptionType {</span>
<span class="nc" id="L98">        NONE, SUBSCRIBE, ASSIGN</span>
    }

    private static final String NOT_RUNNING_EXCEPTION_MESSAGE = &quot;The consumer not running, please start it first.&quot;;

    private static final String SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE = &quot;Subscribe and assign are mutually exclusive.&quot;;
    /**
     * the type of subscription
     */
<span class="nc" id="L107">    private SubscriptionType subscriptionType = SubscriptionType.NONE;</span>
    /**
     * Delay some time when exception occur
     */
<span class="nc" id="L111">    private long pullTimeDelayMillsWhenException = 1000;</span>
    /**
     * Flow control interval
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = 50;
    /**
     * Delay some time when suspend pull service
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_PAUSE = 1000;

    private static final long PULL_TIME_DELAY_MILLS_ON_EXCEPTION = 3 * 1000;

    private DefaultLitePullConsumer defaultLitePullConsumer;

<span class="nc" id="L125">    private final ConcurrentMap&lt;MessageQueue, PullTaskImpl&gt; taskTable =</span>
        new ConcurrentHashMap&lt;MessageQueue, PullTaskImpl&gt;();

<span class="nc" id="L128">    private AssignedMessageQueue assignedMessageQueue = new AssignedMessageQueue();</span>

<span class="nc" id="L130">    private final BlockingQueue&lt;ConsumeRequest&gt; consumeRequestCache = new LinkedBlockingQueue&lt;ConsumeRequest&gt;();</span>

    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;

    private final ScheduledExecutorService scheduledExecutorService;

<span class="nc" id="L136">    private Map&lt;String, TopicMessageQueueChangeListener&gt; topicMessageQueueChangeListenerMap = new HashMap&lt;String, TopicMessageQueueChangeListener&gt;();</span>

<span class="nc" id="L138">    private Map&lt;String, Set&lt;MessageQueue&gt;&gt; messageQueuesForTopic = new HashMap&lt;String, Set&lt;MessageQueue&gt;&gt;();</span>

<span class="nc" id="L140">    private long consumeRequestFlowControlTimes = 0L;</span>

<span class="nc" id="L142">    private long queueFlowControlTimes = 0L;</span>

<span class="nc" id="L144">    private long queueMaxSpanFlowControlTimes = 0L;</span>

<span class="nc" id="L146">    private long nextAutoCommitDeadline = -1L;</span>

<span class="nc" id="L148">    private final MessageQueueLock messageQueueLock = new MessageQueueLock();</span>

<span class="nc" id="L150">    private final ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = new ArrayList&lt;ConsumeMessageHook&gt;();</span>

<span class="nc" id="L152">    public DefaultLitePullConsumerImpl(final DefaultLitePullConsumer defaultLitePullConsumer, final RPCHook rpcHook) {</span>
<span class="nc" id="L153">        this.defaultLitePullConsumer = defaultLitePullConsumer;</span>
<span class="nc" id="L154">        this.rpcHook = rpcHook;</span>
<span class="nc" id="L155">        this.scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(</span>
<span class="nc" id="L156">            this.defaultLitePullConsumer.getPullThreadNums(),</span>
<span class="nc" id="L157">            new ThreadFactoryImpl(&quot;PullMsgThread-&quot; + this.defaultLitePullConsumer.getConsumerGroup())</span>
        );
<span class="nc" id="L159">        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</span>
            @Override
            public Thread newThread(Runnable r) {
<span class="nc" id="L162">                return new Thread(r, &quot;MonitorMessageQueueChangeThread&quot;);</span>
            }
        });
<span class="nc" id="L165">        this.pullTimeDelayMillsWhenException = defaultLitePullConsumer.getPullTimeDelayMillsWhenException();</span>
<span class="nc" id="L166">    }</span>

    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {
<span class="nc" id="L169">        this.consumeMessageHookList.add(hook);</span>
<span class="nc" id="L170">        log.info(&quot;register consumeMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L171">    }</span>

    public void executeHookBefore(final ConsumeMessageContext context) {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L177">                    hook.consumeMessageBefore(context);</span>
<span class="nc" id="L178">                } catch (Throwable e) {</span>
<span class="nc" id="L179">                    log.error(&quot;consumeMessageHook {} executeHookBefore exception&quot;, hook.hookName(), e);</span>
<span class="nc" id="L180">                }</span>
<span class="nc" id="L181">            }</span>
        }
<span class="nc" id="L183">    }</span>

    public void executeHookAfter(final ConsumeMessageContext context) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L189">                    hook.consumeMessageAfter(context);</span>
<span class="nc" id="L190">                } catch (Throwable e) {</span>
<span class="nc" id="L191">                    log.error(&quot;consumeMessageHook {} executeHookAfter exception&quot;, hook.hookName(), e);</span>
<span class="nc" id="L192">                }</span>
<span class="nc" id="L193">            }</span>
        }
<span class="nc" id="L195">    }</span>

    private void checkServiceState() {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (this.serviceState != ServiceState.RUNNING) {</span>
<span class="nc" id="L199">            throw new IllegalStateException(NOT_RUNNING_EXCEPTION_MESSAGE);</span>
        }
<span class="nc" id="L201">    }</span>

    public void updateNameServerAddr(String newAddresses) {
<span class="nc" id="L204">        this.mQClientFactory.getMQClientAPIImpl().updateNameServerAddressList(newAddresses);</span>
<span class="nc" id="L205">    }</span>

    private synchronized void setSubscriptionType(SubscriptionType type) {
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (this.subscriptionType == SubscriptionType.NONE) {</span>
<span class="nc" id="L209">            this.subscriptionType = type;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        } else if (this.subscriptionType != type) {</span>
<span class="nc" id="L211">            throw new IllegalStateException(SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE);</span>
        }
<span class="nc" id="L213">    }</span>

    private void updateAssignedMessageQueue(String topic, Set&lt;MessageQueue&gt; assignedMessageQueue) {
<span class="nc" id="L216">        this.assignedMessageQueue.updateAssignedMessageQueue(topic, assignedMessageQueue);</span>
<span class="nc" id="L217">    }</span>

    private void updatePullTask(String topic, Set&lt;MessageQueue&gt; mqNewSet) {
<span class="nc" id="L220">        Iterator&lt;Map.Entry&lt;MessageQueue, PullTaskImpl&gt;&gt; it = this.taskTable.entrySet().iterator();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L222">            Map.Entry&lt;MessageQueue, PullTaskImpl&gt; next = it.next();</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (next.getKey().getTopic().equals(topic)) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                if (!mqNewSet.contains(next.getKey())) {</span>
<span class="nc" id="L225">                    next.getValue().setCancelled(true);</span>
<span class="nc" id="L226">                    it.remove();</span>
                }
            }
<span class="nc" id="L229">        }</span>
<span class="nc" id="L230">        startPullTask(mqNewSet);</span>
<span class="nc" id="L231">    }</span>

<span class="nc" id="L233">    class MessageQueueListenerImpl implements MessageQueueListener {</span>
        @Override
        public void messageQueueChanged(String topic, Set&lt;MessageQueue&gt; mqAll, Set&lt;MessageQueue&gt; mqDivided) {
<span class="nc" id="L236">            MessageModel messageModel = defaultLitePullConsumer.getMessageModel();</span>
<span class="nc bnc" id="L237" title="All 3 branches missed.">            switch (messageModel) {</span>
                case BROADCASTING:
<span class="nc" id="L239">                    updateAssignedMessageQueue(topic, mqAll);</span>
<span class="nc" id="L240">                    updatePullTask(topic, mqAll);</span>
<span class="nc" id="L241">                    break;</span>
                case CLUSTERING:
<span class="nc" id="L243">                    updateAssignedMessageQueue(topic, mqDivided);</span>
<span class="nc" id="L244">                    updatePullTask(topic, mqDivided);</span>
<span class="nc" id="L245">                    break;</span>
                default:
                    break;
            }
<span class="nc" id="L249">        }</span>
    }

    public synchronized void shutdown() {
<span class="nc bnc" id="L253" title="All 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L255">                break;</span>
            case RUNNING:
<span class="nc" id="L257">                persistConsumerOffset();</span>
<span class="nc" id="L258">                this.mQClientFactory.unregisterConsumer(this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="nc" id="L259">                scheduledThreadPoolExecutor.shutdown();</span>
<span class="nc" id="L260">                scheduledExecutorService.shutdown();</span>
<span class="nc" id="L261">                this.mQClientFactory.shutdown();</span>
<span class="nc" id="L262">                this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span>
<span class="nc" id="L263">                log.info(&quot;the consumer [{}] shutdown OK&quot;, this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="nc" id="L264">                break;</span>
            default:
                break;
        }
<span class="nc" id="L268">    }</span>

    public synchronized boolean isRunning() {
<span class="nc bnc" id="L271" title="All 2 branches missed.">        return this.serviceState == ServiceState.RUNNING;</span>
    }

    public synchronized void start() throws MQClientException {
<span class="nc bnc" id="L275" title="All 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L277">                this.serviceState = ServiceState.START_FAILED;</span>

<span class="nc" id="L279">                this.checkConfig();</span>

<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (this.defaultLitePullConsumer.getMessageModel() == MessageModel.CLUSTERING) {</span>
<span class="nc" id="L282">                    this.defaultLitePullConsumer.changeInstanceNameToPID();</span>
                }

<span class="nc" id="L285">                initMQClientFactory();</span>

<span class="nc" id="L287">                initRebalanceImpl();</span>

<span class="nc" id="L289">                initPullAPIWrapper();</span>

<span class="nc" id="L291">                initOffsetStore();</span>

<span class="nc" id="L293">                mQClientFactory.start();</span>

<span class="nc" id="L295">                startScheduleTask();</span>

<span class="nc" id="L297">                this.serviceState = ServiceState.RUNNING;</span>

<span class="nc" id="L299">                log.info(&quot;the consumer [{}] start OK&quot;, this.defaultLitePullConsumer.getConsumerGroup());</span>

<span class="nc" id="L301">                operateAfterRunning();</span>

<span class="nc" id="L303">                break;</span>
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
<span class="nc" id="L307">                throw new MQClientException(&quot;The PullConsumer service state not OK, maybe started once, &quot;</span>
                    + this.serviceState
<span class="nc" id="L309">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                    null);
            default:
                break;
        }
<span class="nc" id="L314">    }</span>

    private void initMQClientFactory() throws MQClientException {
<span class="nc" id="L317">        this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultLitePullConsumer, this.rpcHook);</span>
<span class="nc" id="L318">        boolean registerOK = mQClientFactory.registerConsumer(this.defaultLitePullConsumer.getConsumerGroup(), this);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (!registerOK) {</span>
<span class="nc" id="L320">            this.serviceState = ServiceState.CREATE_JUST;</span>

<span class="nc" id="L322">            throw new MQClientException(&quot;The consumer group[&quot; + this.defaultLitePullConsumer.getConsumerGroup()</span>
<span class="nc" id="L323">                + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span>
                null);
        }
<span class="nc" id="L326">    }</span>

    private void initRebalanceImpl() {
<span class="nc" id="L329">        this.rebalanceImpl.setConsumerGroup(this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="nc" id="L330">        this.rebalanceImpl.setMessageModel(this.defaultLitePullConsumer.getMessageModel());</span>
<span class="nc" id="L331">        this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultLitePullConsumer.getAllocateMessageQueueStrategy());</span>
<span class="nc" id="L332">        this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span>
<span class="nc" id="L333">    }</span>

    private void initPullAPIWrapper() {
<span class="nc" id="L336">        this.pullAPIWrapper = new PullAPIWrapper(</span>
            mQClientFactory,
<span class="nc" id="L338">            this.defaultLitePullConsumer.getConsumerGroup(), isUnitMode());</span>
<span class="nc" id="L339">        this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span>
<span class="nc" id="L340">    }</span>

    private void initOffsetStore() throws MQClientException {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (this.defaultLitePullConsumer.getOffsetStore() != null) {</span>
<span class="nc" id="L344">            this.offsetStore = this.defaultLitePullConsumer.getOffsetStore();</span>
        } else {
<span class="nc bnc" id="L346" title="All 3 branches missed.">            switch (this.defaultLitePullConsumer.getMessageModel()) {</span>
                case BROADCASTING:
<span class="nc" id="L348">                    this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="nc" id="L349">                    break;</span>
                case CLUSTERING:
<span class="nc" id="L351">                    this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="nc" id="L352">                    break;</span>
                default:
                    break;
            }
<span class="nc" id="L356">            this.defaultLitePullConsumer.setOffsetStore(this.offsetStore);</span>
        }
<span class="nc" id="L358">        this.offsetStore.load();</span>
<span class="nc" id="L359">    }</span>

    private void startScheduleTask() {
<span class="nc" id="L362">        scheduledExecutorService.scheduleAtFixedRate(</span>
<span class="nc" id="L363">            new Runnable() {</span>
                @Override
                public void run() {
                    try {
<span class="nc" id="L367">                        fetchTopicMessageQueuesAndCompare();</span>
<span class="nc" id="L368">                    } catch (Exception e) {</span>
<span class="nc" id="L369">                        log.error(&quot;ScheduledTask fetchMessageQueuesAndCompare exception&quot;, e);</span>
<span class="nc" id="L370">                    }</span>
<span class="nc" id="L371">                }</span>
<span class="nc" id="L372">            }, 1000 * 10, this.getDefaultLitePullConsumer().getTopicMetadataCheckIntervalMillis(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L373">    }</span>

    private void operateAfterRunning() throws MQClientException {
        // If subscribe function invoke before start function, then update topic subscribe info after initialization.
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="nc" id="L378">            updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
        }
        // If assign function invoke before start function, then update pull task after initialization.
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (subscriptionType == SubscriptionType.ASSIGN) {</span>
<span class="nc" id="L382">            updateAssignPullTask(assignedMessageQueue.messageQueues());</span>
        }

<span class="nc bnc" id="L385" title="All 2 branches missed.">        for (String topic : topicMessageQueueChangeListenerMap.keySet()) {</span>
<span class="nc" id="L386">            Set&lt;MessageQueue&gt; messageQueues = fetchMessageQueues(topic);</span>
<span class="nc" id="L387">            messageQueuesForTopic.put(topic, messageQueues);</span>
<span class="nc" id="L388">        }</span>
<span class="nc" id="L389">        this.mQClientFactory.checkClientInBroker();</span>
<span class="nc" id="L390">    }</span>

    private void checkConfig() throws MQClientException {
        // Check consumerGroup
<span class="nc" id="L394">        Validators.checkGroup(this.defaultLitePullConsumer.getConsumerGroup());</span>

        // Check consumerGroup name is not equal default consumer group name.
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (this.defaultLitePullConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {</span>
<span class="nc" id="L398">            throw new MQClientException(</span>
                &quot;consumerGroup can not equal &quot;
                    + MixAll.DEFAULT_CONSUMER_GROUP
                    + &quot;, please specify another one.&quot;
<span class="nc" id="L402">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // Check messageModel is not null.
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (null == this.defaultLitePullConsumer.getMessageModel()) {</span>
<span class="nc" id="L408">            throw new MQClientException(</span>
                &quot;messageModel is null&quot;
<span class="nc" id="L410">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // Check allocateMessageQueueStrategy is not null
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (null == this.defaultLitePullConsumer.getAllocateMessageQueueStrategy()) {</span>
<span class="nc" id="L416">            throw new MQClientException(</span>
                &quot;allocateMessageQueueStrategy is null&quot;
<span class="nc" id="L418">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (this.defaultLitePullConsumer.getConsumerTimeoutMillisWhenSuspend() &lt; this.defaultLitePullConsumer.getBrokerSuspendMaxTimeMillis()) {</span>
<span class="nc" id="L423">            throw new MQClientException(</span>
                &quot;Long polling mode, the consumer consumerTimeoutMillisWhenSuspend must greater than brokerSuspendMaxTimeMillis&quot;
<span class="nc" id="L425">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }
<span class="nc" id="L428">    }</span>

    public PullAPIWrapper getPullAPIWrapper() {
<span class="nc" id="L431">        return pullAPIWrapper;</span>
    }

    private void startPullTask(Collection&lt;MessageQueue&gt; mqSet) {
<span class="nc bnc" id="L435" title="All 2 branches missed.">        for (MessageQueue messageQueue : mqSet) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (!this.taskTable.containsKey(messageQueue)) {</span>
<span class="nc" id="L437">                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);</span>
<span class="nc" id="L438">                this.taskTable.put(messageQueue, pullTask);</span>
<span class="nc" id="L439">                this.scheduledThreadPoolExecutor.schedule(pullTask, 0, TimeUnit.MILLISECONDS);</span>
            }
<span class="nc" id="L441">        }</span>
<span class="nc" id="L442">    }</span>

    private void updateAssignPullTask(Collection&lt;MessageQueue&gt; mqNewSet) {
<span class="nc" id="L445">        Iterator&lt;Map.Entry&lt;MessageQueue, PullTaskImpl&gt;&gt; it = this.taskTable.entrySet().iterator();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L447">            Map.Entry&lt;MessageQueue, PullTaskImpl&gt; next = it.next();</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (!mqNewSet.contains(next.getKey())) {</span>
<span class="nc" id="L449">                next.getValue().setCancelled(true);</span>
<span class="nc" id="L450">                it.remove();</span>
            }
<span class="nc" id="L452">        }</span>

<span class="nc" id="L454">        startPullTask(mqNewSet);</span>
<span class="nc" id="L455">    }</span>

    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {
<span class="nc" id="L458">        Map&lt;String, SubscriptionData&gt; subTable = rebalanceImpl.getSubscriptionInner();</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) {</span>
<span class="nc" id="L461">                final String topic = entry.getKey();</span>
<span class="nc" id="L462">                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="nc" id="L463">            }</span>
        }
<span class="nc" id="L465">    }</span>

    public synchronized void subscribe(String topic, String subExpression) throws MQClientException {
        try {
<span class="nc bnc" id="L469" title="All 4 branches missed.">            if (topic == null || &quot;&quot;.equals(topic)) {</span>
<span class="nc" id="L470">                throw new IllegalArgumentException(&quot;Topic can not be null or empty.&quot;);</span>
            }
<span class="nc" id="L472">            setSubscriptionType(SubscriptionType.SUBSCRIBE);</span>
<span class="nc" id="L473">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression);</span>
<span class="nc" id="L474">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L475">            this.defaultLitePullConsumer.setMessageQueueListener(new MessageQueueListenerImpl());</span>
<span class="nc" id="L476">            assignedMessageQueue.setRebalanceImpl(this.rebalanceImpl);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (serviceState == ServiceState.RUNNING) {</span>
<span class="nc" id="L478">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
<span class="nc" id="L479">                updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
            }
<span class="nc" id="L481">        } catch (Exception e) {</span>
<span class="nc" id="L482">            throw new MQClientException(&quot;subscribe exception&quot;, e);</span>
<span class="nc" id="L483">        }</span>
<span class="nc" id="L484">    }</span>

    public synchronized void subscribe(String topic, MessageSelector messageSelector) throws MQClientException {
        try {
<span class="nc bnc" id="L488" title="All 4 branches missed.">            if (topic == null || &quot;&quot;.equals(topic)) {</span>
<span class="nc" id="L489">                throw new IllegalArgumentException(&quot;Topic can not be null or empty.&quot;);</span>
            }
<span class="nc" id="L491">            setSubscriptionType(SubscriptionType.SUBSCRIBE);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (messageSelector == null) {</span>
<span class="nc" id="L493">                subscribe(topic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L494">                return;</span>
            }
<span class="nc" id="L496">            SubscriptionData subscriptionData = FilterAPI.build(topic,</span>
<span class="nc" id="L497">                messageSelector.getExpression(), messageSelector.getExpressionType());</span>
<span class="nc" id="L498">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L499">            this.defaultLitePullConsumer.setMessageQueueListener(new MessageQueueListenerImpl());</span>
<span class="nc" id="L500">            assignedMessageQueue.setRebalanceImpl(this.rebalanceImpl);</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (serviceState == ServiceState.RUNNING) {</span>
<span class="nc" id="L502">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
<span class="nc" id="L503">                updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
            }
<span class="nc" id="L505">        } catch (Exception e) {</span>
<span class="nc" id="L506">            throw new MQClientException(&quot;subscribe exception&quot;, e);</span>
<span class="nc" id="L507">        }</span>
<span class="nc" id="L508">    }</span>

    public synchronized void unsubscribe(final String topic) {
<span class="nc" id="L511">        this.rebalanceImpl.getSubscriptionInner().remove(topic);</span>
<span class="nc" id="L512">        removePullTaskCallback(topic);</span>
<span class="nc" id="L513">        assignedMessageQueue.removeAssignedMessageQueue(topic);</span>
<span class="nc" id="L514">    }</span>

    public synchronized void assign(Collection&lt;MessageQueue&gt; messageQueues) {
<span class="nc bnc" id="L517" title="All 4 branches missed.">        if (messageQueues == null || messageQueues.isEmpty()) {</span>
<span class="nc" id="L518">            throw new IllegalArgumentException(&quot;Message queues can not be null or empty.&quot;);</span>
        }
<span class="nc" id="L520">        setSubscriptionType(SubscriptionType.ASSIGN);</span>
<span class="nc" id="L521">        assignedMessageQueue.updateAssignedMessageQueue(messageQueues);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (serviceState == ServiceState.RUNNING) {</span>
<span class="nc" id="L523">            updateAssignPullTask(messageQueues);</span>
        }
<span class="nc" id="L525">    }</span>

    private void maybeAutoCommit() {
<span class="nc" id="L528">        long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (now &gt;= nextAutoCommitDeadline) {</span>
<span class="nc" id="L530">            commitAll();</span>
<span class="nc" id="L531">            nextAutoCommitDeadline = now + defaultLitePullConsumer.getAutoCommitIntervalMillis();</span>
        }
<span class="nc" id="L533">    }</span>

    public synchronized List&lt;MessageExt&gt; poll(long timeout) {
        try {
<span class="nc" id="L537">            checkServiceState();</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (timeout &lt; 0) {</span>
<span class="nc" id="L539">                throw new IllegalArgumentException(&quot;Timeout must not be negative&quot;);</span>
            }

<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (defaultLitePullConsumer.isAutoCommit()) {</span>
<span class="nc" id="L543">                maybeAutoCommit();</span>
            }
<span class="nc" id="L545">            long endTime = System.currentTimeMillis() + timeout;</span>

<span class="nc" id="L547">            ConsumeRequest consumeRequest = consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span>

<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (endTime - System.currentTimeMillis() &gt; 0) {</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">                while (consumeRequest != null &amp;&amp; consumeRequest.getProcessQueue().isDropped()) {</span>
<span class="nc" id="L551">                    consumeRequest = consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                    if (endTime - System.currentTimeMillis() &lt;= 0) {</span>
<span class="nc" id="L553">                        break;</span>
                    }
                }
            }

<span class="nc bnc" id="L558" title="All 4 branches missed.">            if (consumeRequest != null &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) {</span>
<span class="nc" id="L559">                List&lt;MessageExt&gt; messages = consumeRequest.getMessageExts();</span>
<span class="nc" id="L560">                long offset = consumeRequest.getProcessQueue().removeMessage(messages);</span>
<span class="nc" id="L561">                assignedMessageQueue.updateConsumeOffset(consumeRequest.getMessageQueue(), offset);</span>
                //If namespace not null , reset Topic without namespace.
<span class="nc" id="L563">                this.resetTopic(messages);</span>
<span class="nc" id="L564">                return messages;</span>
            }
<span class="nc" id="L566">        } catch (InterruptedException ignore) {</span>

<span class="nc" id="L568">        }</span>

<span class="nc" id="L570">        return Collections.emptyList();</span>
    }

    public void pause(Collection&lt;MessageQueue&gt; messageQueues) {
<span class="nc" id="L574">        assignedMessageQueue.pause(messageQueues);</span>
<span class="nc" id="L575">    }</span>

    public void resume(Collection&lt;MessageQueue&gt; messageQueues) {
<span class="nc" id="L578">        assignedMessageQueue.resume(messageQueues);</span>
<span class="nc" id="L579">    }</span>

    public synchronized void seek(MessageQueue messageQueue, long offset) throws MQClientException {
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (!assignedMessageQueue.messageQueues().contains(messageQueue)) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="nc" id="L584">                throw new MQClientException(&quot;The message queue is not in assigned list, may be rebalancing, message queue: &quot; + messageQueue, null);</span>
            } else {
<span class="nc" id="L586">                throw new MQClientException(&quot;The message queue is not in assigned list, message queue: &quot; + messageQueue, null);</span>
            }
        }
<span class="nc" id="L589">        long minOffset = minOffset(messageQueue);</span>
<span class="nc" id="L590">        long maxOffset = maxOffset(messageQueue);</span>
<span class="nc bnc" id="L591" title="All 4 branches missed.">        if (offset &lt; minOffset || offset &gt; maxOffset) {</span>
<span class="nc" id="L592">            throw new MQClientException(&quot;Seek offset illegal, seek offset = &quot; + offset + &quot;, min offset = &quot; + minOffset + &quot;, max offset = &quot; + maxOffset, null);</span>
        }
<span class="nc" id="L594">        final Object objLock = messageQueueLock.fetchLockObject(messageQueue);</span>
<span class="nc" id="L595">        synchronized (objLock) {</span>
<span class="nc" id="L596">            clearMessageQueueInCache(messageQueue);</span>

<span class="nc" id="L598">            PullTaskImpl oldPullTaskImpl = this.taskTable.get(messageQueue);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (oldPullTaskImpl != null) {</span>
<span class="nc" id="L600">                oldPullTaskImpl.tryInterrupt();</span>
<span class="nc" id="L601">                this.taskTable.remove(messageQueue);</span>
            }
<span class="nc" id="L603">            assignedMessageQueue.setSeekOffset(messageQueue, offset);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">            if (!this.taskTable.containsKey(messageQueue)) {</span>
<span class="nc" id="L605">                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);</span>
<span class="nc" id="L606">                this.taskTable.put(messageQueue, pullTask);</span>
<span class="nc" id="L607">                this.scheduledThreadPoolExecutor.schedule(pullTask, 0, TimeUnit.MILLISECONDS);</span>
            }
<span class="nc" id="L609">        }</span>
<span class="nc" id="L610">    }</span>

    public void seekToBegin(MessageQueue messageQueue) throws MQClientException {
<span class="nc" id="L613">        long begin = minOffset(messageQueue);</span>
<span class="nc" id="L614">        this.seek(messageQueue, begin);</span>
<span class="nc" id="L615">    }</span>

    public void seekToEnd(MessageQueue messageQueue) throws MQClientException {
<span class="nc" id="L618">        long end = maxOffset(messageQueue);</span>
<span class="nc" id="L619">        this.seek(messageQueue, end);</span>
<span class="nc" id="L620">    }</span>

    private long maxOffset(MessageQueue messageQueue) throws MQClientException {
<span class="nc" id="L623">        checkServiceState();</span>
<span class="nc" id="L624">        return this.mQClientFactory.getMQAdminImpl().maxOffset(messageQueue);</span>
    }

    private long minOffset(MessageQueue messageQueue) throws MQClientException {
<span class="nc" id="L628">        checkServiceState();</span>
<span class="nc" id="L629">        return this.mQClientFactory.getMQAdminImpl().minOffset(messageQueue);</span>
    }

    private void removePullTaskCallback(final String topic) {
<span class="nc" id="L633">        removePullTask(topic);</span>
<span class="nc" id="L634">    }</span>

    private void removePullTask(final String topic) {
<span class="nc" id="L637">        Iterator&lt;Map.Entry&lt;MessageQueue, PullTaskImpl&gt;&gt; it = this.taskTable.entrySet().iterator();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L639">            Map.Entry&lt;MessageQueue, PullTaskImpl&gt; next = it.next();</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">            if (next.getKey().getTopic().equals(topic)) {</span>
<span class="nc" id="L641">                next.getValue().setCancelled(true);</span>
<span class="nc" id="L642">                it.remove();</span>
            }
<span class="nc" id="L644">        }</span>
<span class="nc" id="L645">    }</span>

    public synchronized void commitAll() {
<span class="nc bnc" id="L648" title="All 2 branches missed.">        for (MessageQueue messageQueue : assignedMessageQueue.messageQueues()) {</span>
            try {
<span class="nc" id="L650">                commit(messageQueue);</span>
<span class="nc" id="L651">            } catch (Exception e) {</span>
<span class="nc" id="L652">                log.error(&quot;An error occurred when update consume offset Automatically.&quot;);</span>
<span class="nc" id="L653">            }</span>
<span class="nc" id="L654">        }</span>
<span class="nc" id="L655">    }</span>

    public synchronized void commit(final Set&lt;MessageQueue&gt; messageQueues, boolean persist) {
<span class="nc bnc" id="L658" title="All 4 branches missed.">        if (messageQueues == null || messageQueues.size() == 0) {</span>
<span class="nc" id="L659">            return;</span>
        }

<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (MessageQueue messageQueue : messageQueues) {</span>
<span class="nc" id="L663">            commit(messageQueue);</span>
<span class="nc" id="L664">        }</span>

<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (persist) {</span>
<span class="nc" id="L667">            this.offsetStore.persistAll(messageQueues);</span>
        }
<span class="nc" id="L669">    }</span>

    private synchronized void commit(MessageQueue messageQueue) {
<span class="nc" id="L672">        long consumerOffset = assignedMessageQueue.getConsumerOffset(messageQueue);</span>

<span class="nc bnc" id="L674" title="All 2 branches missed.">        if (consumerOffset != -1) {</span>
<span class="nc" id="L675">            ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);</span>
<span class="nc bnc" id="L676" title="All 4 branches missed.">            if (processQueue != null &amp;&amp; !processQueue.isDropped()) {</span>
<span class="nc" id="L677">                updateConsumeOffset(messageQueue, consumerOffset);</span>
            }
<span class="nc" id="L679">        } else {</span>
<span class="nc" id="L680">            log.error(&quot;consumerOffset is -1 in messageQueue [&quot; + messageQueue + &quot;].&quot;);</span>
        }
<span class="nc" id="L682">    }</span>

    private void updatePullOffset(MessageQueue messageQueue, long nextPullOffset, ProcessQueue processQueue) {
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (assignedMessageQueue.getSeekOffset(messageQueue) == -1) {</span>
<span class="nc" id="L686">            assignedMessageQueue.updatePullOffset(messageQueue, nextPullOffset, processQueue);</span>
        }
<span class="nc" id="L688">    }</span>

    private void submitConsumeRequest(ConsumeRequest consumeRequest) {
        try {
<span class="nc" id="L692">            consumeRequestCache.put(consumeRequest);</span>
<span class="nc" id="L693">        } catch (InterruptedException e) {</span>
<span class="nc" id="L694">            log.error(&quot;Submit consumeRequest error&quot;, e);</span>
<span class="nc" id="L695">        }</span>
<span class="nc" id="L696">    }</span>

    private long fetchConsumeOffset(MessageQueue messageQueue) throws MQClientException {
<span class="nc" id="L699">        checkServiceState();</span>
<span class="nc" id="L700">        long offset = this.rebalanceImpl.computePullFromWhereWithException(messageQueue);</span>
<span class="nc" id="L701">        return offset;</span>
    }

    public long committed(MessageQueue messageQueue) throws MQClientException {
<span class="nc" id="L705">        checkServiceState();</span>
<span class="nc" id="L706">        long offset = this.offsetStore.readOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE);</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (offset == -2) {</span>
<span class="nc" id="L708">            throw new MQClientException(&quot;Fetch consume offset from broker exception&quot;, null);</span>
        }
<span class="nc" id="L710">        return offset;</span>
    }

    private void clearMessageQueueInCache(MessageQueue messageQueue) {
<span class="nc" id="L714">        ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (processQueue != null) {</span>
<span class="nc" id="L716">            processQueue.clear();</span>
        }
<span class="nc" id="L718">        Iterator&lt;ConsumeRequest&gt; iter = consumeRequestCache.iterator();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">            if (iter.next().getMessageQueue().equals(messageQueue)) {</span>
<span class="nc" id="L721">                iter.remove();</span>
            }
        }
<span class="nc" id="L724">    }</span>

    private long nextPullOffset(MessageQueue messageQueue) throws MQClientException {
<span class="nc" id="L727">        long offset = -1;</span>
<span class="nc" id="L728">        long seekOffset = assignedMessageQueue.getSeekOffset(messageQueue);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (seekOffset != -1) {</span>
<span class="nc" id="L730">            offset = seekOffset;</span>
<span class="nc" id="L731">            assignedMessageQueue.updateConsumeOffset(messageQueue, offset);</span>
<span class="nc" id="L732">            assignedMessageQueue.setSeekOffset(messageQueue, -1);</span>
        } else {
<span class="nc" id="L734">            offset = assignedMessageQueue.getPullOffset(messageQueue);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">            if (offset == -1) {</span>
<span class="nc" id="L736">                offset = fetchConsumeOffset(messageQueue);</span>
            }
        }
<span class="nc" id="L739">        return offset;</span>
    }

    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="nc" id="L743">        checkServiceState();</span>
<span class="nc" id="L744">        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span>
    }

    public class PullTaskImpl implements Runnable {
        private final MessageQueue messageQueue;
<span class="nc" id="L749">        private volatile boolean cancelled = false;</span>
        private Thread currentThread;

<span class="nc" id="L752">        public PullTaskImpl(final MessageQueue messageQueue) {</span>
<span class="nc" id="L753">            this.messageQueue = messageQueue;</span>
<span class="nc" id="L754">        }</span>

        public void tryInterrupt() {
<span class="nc" id="L757">            setCancelled(true);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (currentThread == null) {</span>
<span class="nc" id="L759">                return;</span>
            }
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (!currentThread.isInterrupted()) {</span>
<span class="nc" id="L762">                currentThread.interrupt();</span>
            }
<span class="nc" id="L764">        }</span>

        @Override
        public void run() {

<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (!this.isCancelled()) {</span>

<span class="nc" id="L771">                this.currentThread = Thread.currentThread();</span>

<span class="nc bnc" id="L773" title="All 2 branches missed.">                if (assignedMessageQueue.isPaused(messageQueue)) {</span>
<span class="nc" id="L774">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_PAUSE, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L775">                    log.debug(&quot;Message Queue: {} has been paused!&quot;, messageQueue);</span>
<span class="nc" id="L776">                    return;</span>
                }

<span class="nc" id="L779">                ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);</span>

<span class="nc bnc" id="L781" title="All 4 branches missed.">                if (null == processQueue || processQueue.isDropped()) {</span>
<span class="nc" id="L782">                    log.info(&quot;The message queue not be able to poll, because it's dropped. group={}, messageQueue={}&quot;, defaultLitePullConsumer.getConsumerGroup(), this.messageQueue);</span>
<span class="nc" id="L783">                    return;</span>
                }

<span class="nc bnc" id="L786" title="All 2 branches missed.">                if ((long) consumeRequestCache.size() * defaultLitePullConsumer.getPullBatchSize() &gt; defaultLitePullConsumer.getPullThresholdForAll()) {</span>
<span class="nc" id="L787">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                    if ((consumeRequestFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L789">                        log.warn(&quot;The consume request count exceeds threshold {}, so do flow control, consume request count={}, flowControlTimes={}&quot;, consumeRequestCache.size(), consumeRequestFlowControlTimes);</span>
                    }
<span class="nc" id="L791">                    return;</span>
                }

<span class="nc" id="L794">                long cachedMessageCount = processQueue.getMsgCount().get();</span>
<span class="nc" id="L795">                long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);</span>

<span class="nc bnc" id="L797" title="All 2 branches missed.">                if (cachedMessageCount &gt; defaultLitePullConsumer.getPullThresholdForQueue()) {</span>
<span class="nc" id="L798">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                    if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L800">                        log.warn(</span>
                            &quot;The cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, flowControlTimes={}&quot;,
<span class="nc" id="L802">                            defaultLitePullConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, queueFlowControlTimes);</span>
                    }
<span class="nc" id="L804">                    return;</span>
                }

<span class="nc bnc" id="L807" title="All 2 branches missed.">                if (cachedMessageSizeInMiB &gt; defaultLitePullConsumer.getPullThresholdSizeForQueue()) {</span>
<span class="nc" id="L808">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">                    if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L810">                        log.warn(</span>
                            &quot;The cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, flowControlTimes={}&quot;,
<span class="nc" id="L812">                            defaultLitePullConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, queueFlowControlTimes);</span>
                    }
<span class="nc" id="L814">                    return;</span>
                }

<span class="nc bnc" id="L817" title="All 2 branches missed.">                if (processQueue.getMaxSpan() &gt; defaultLitePullConsumer.getConsumeMaxSpan()) {</span>
<span class="nc" id="L818">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">                    if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L820">                        log.warn(</span>
                            &quot;The queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, flowControlTimes={}&quot;,
<span class="nc" id="L822">                            processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(), queueMaxSpanFlowControlTimes);</span>
                    }
<span class="nc" id="L824">                    return;</span>
                }

<span class="nc" id="L827">                long offset = 0L;</span>
                try {
<span class="nc" id="L829">                    offset = nextPullOffset(messageQueue);</span>
<span class="nc" id="L830">                } catch (Exception e) {</span>
<span class="nc" id="L831">                    log.error(&quot;Failed to get next pull offset&quot;, e);</span>
<span class="nc" id="L832">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_ON_EXCEPTION, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L833">                    return;</span>
<span class="nc" id="L834">                }</span>

<span class="nc bnc" id="L836" title="All 4 branches missed.">                if (this.isCancelled() || processQueue.isDropped()) {</span>
<span class="nc" id="L837">                    return;</span>
                }
<span class="nc" id="L839">                long pullDelayTimeMills = 0;</span>
                try {
                    SubscriptionData subscriptionData;
<span class="nc" id="L842">                    String topic = this.messageQueue.getTopic();</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">                    if (subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="nc" id="L844">                        subscriptionData = rebalanceImpl.getSubscriptionInner().get(topic);</span>
                    } else {
<span class="nc" id="L846">                        subscriptionData = FilterAPI.buildSubscriptionData(topic, SubscriptionData.SUB_ALL);</span>
                    }

<span class="nc" id="L849">                    PullResult pullResult = pull(messageQueue, subscriptionData, offset, defaultLitePullConsumer.getPullBatchSize());</span>
<span class="nc bnc" id="L850" title="All 4 branches missed.">                    if (this.isCancelled() || processQueue.isDropped()) {</span>
<span class="nc" id="L851">                        return;</span>
                    }
<span class="nc bnc" id="L853" title="All 3 branches missed.">                    switch (pullResult.getPullStatus()) {</span>
                        case FOUND:
<span class="nc" id="L855">                            final Object objLock = messageQueueLock.fetchLockObject(messageQueue);</span>
<span class="nc" id="L856">                            synchronized (objLock) {</span>
<span class="nc bnc" id="L857" title="All 6 branches missed.">                                if (pullResult.getMsgFoundList() != null &amp;&amp; !pullResult.getMsgFoundList().isEmpty() &amp;&amp; assignedMessageQueue.getSeekOffset(messageQueue) == -1) {</span>
<span class="nc" id="L858">                                    processQueue.putMessage(pullResult.getMsgFoundList());</span>
<span class="nc" id="L859">                                    submitConsumeRequest(new ConsumeRequest(pullResult.getMsgFoundList(), messageQueue, processQueue));</span>
                                }
<span class="nc" id="L861">                            }</span>
<span class="nc" id="L862">                            break;</span>
                        case OFFSET_ILLEGAL:
<span class="nc" id="L864">                            log.warn(&quot;The pull request offset illegal, {}&quot;, pullResult.toString());</span>
<span class="nc" id="L865">                            break;</span>
                        default:
                            break;
                    }
<span class="nc" id="L869">                    updatePullOffset(messageQueue, pullResult.getNextBeginOffset(), processQueue);</span>
<span class="nc" id="L870">                } catch (InterruptedException interruptedException) {</span>
<span class="nc" id="L871">                    log.warn(&quot;Polling thread was interrupted.&quot;, interruptedException);</span>
<span class="nc" id="L872">                } catch (Throwable e) {</span>
<span class="nc" id="L873">                    pullDelayTimeMills = pullTimeDelayMillsWhenException;</span>
<span class="nc" id="L874">                    log.error(&quot;An error occurred in pull message process.&quot;, e);</span>
<span class="nc" id="L875">                }</span>

<span class="nc bnc" id="L877" title="All 2 branches missed.">                if (!this.isCancelled()) {</span>
<span class="nc" id="L878">                    scheduledThreadPoolExecutor.schedule(this, pullDelayTimeMills, TimeUnit.MILLISECONDS);</span>
                } else {
<span class="nc" id="L880">                    log.warn(&quot;The Pull Task is cancelled after doPullTask, {}&quot;, messageQueue);</span>
                }
            }
<span class="nc" id="L883">        }</span>

        public boolean isCancelled() {
<span class="nc" id="L886">            return cancelled;</span>
        }

        public void setCancelled(boolean cancelled) {
<span class="nc" id="L890">            this.cancelled = cancelled;</span>
<span class="nc" id="L891">        }</span>

        public MessageQueue getMessageQueue() {
<span class="nc" id="L894">            return messageQueue;</span>
        }
    }

    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L900">        return pull(mq, subscriptionData, offset, maxNums, this.defaultLitePullConsumer.getConsumerPullTimeoutMillis());</span>
    }

    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums, long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L905">        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, true, timeout);</span>
    }

    private PullResult pullSyncImpl(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums,
        boolean block,
        long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {

<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (null == mq) {</span>
<span class="nc" id="L914">            throw new MQClientException(&quot;mq is null&quot;, null);</span>
        }

<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (offset &lt; 0) {</span>
<span class="nc" id="L918">            throw new MQClientException(&quot;offset &lt; 0&quot;, null);</span>
        }

<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (maxNums &lt;= 0) {</span>
<span class="nc" id="L922">            throw new MQClientException(&quot;maxNums &lt;= 0&quot;, null);</span>
        }

<span class="nc" id="L925">        int sysFlag = PullSysFlag.buildSysFlag(false, block, true, false, true);</span>

<span class="nc bnc" id="L927" title="All 2 branches missed.">        long timeoutMillis = block ? this.defaultLitePullConsumer.getConsumerTimeoutMillisWhenSuspend() : timeout;</span>

<span class="nc" id="L929">        boolean isTagType = ExpressionType.isTagType(subscriptionData.getExpressionType());</span>
<span class="nc" id="L930">        PullResult pullResult = this.pullAPIWrapper.pullKernelImpl(</span>
            mq,
<span class="nc" id="L932">            subscriptionData.getSubString(),</span>
<span class="nc" id="L933">            subscriptionData.getExpressionType(),</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">            isTagType ? 0L : subscriptionData.getSubVersion(),</span>
            offset,
            maxNums,
            sysFlag,
            0,
<span class="nc" id="L939">            this.defaultLitePullConsumer.getBrokerSuspendMaxTimeMillis(),</span>
            timeoutMillis,
            CommunicationMode.SYNC,
            null
        );
<span class="nc" id="L944">        this.pullAPIWrapper.processPullResult(mq, pullResult, subscriptionData);</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc" id="L946">            ConsumeMessageContext consumeMessageContext = new ConsumeMessageContext();</span>
<span class="nc" id="L947">            consumeMessageContext.setNamespace(defaultLitePullConsumer.getNamespace());</span>
<span class="nc" id="L948">            consumeMessageContext.setConsumerGroup(this.groupName());</span>
<span class="nc" id="L949">            consumeMessageContext.setMq(mq);</span>
<span class="nc" id="L950">            consumeMessageContext.setMsgList(pullResult.getMsgFoundList());</span>
<span class="nc" id="L951">            consumeMessageContext.setSuccess(false);</span>
<span class="nc" id="L952">            this.executeHookBefore(consumeMessageContext);</span>
<span class="nc" id="L953">            consumeMessageContext.setStatus(ConsumeConcurrentlyStatus.CONSUME_SUCCESS.toString());</span>
<span class="nc" id="L954">            consumeMessageContext.setSuccess(true);</span>
<span class="nc" id="L955">            this.executeHookAfter(consumeMessageContext);</span>
        }
<span class="nc" id="L957">        return pullResult;</span>
    }

    private void resetTopic(List&lt;MessageExt&gt; msgList) {
<span class="nc bnc" id="L961" title="All 4 branches missed.">        if (null == msgList || msgList.size() == 0) {</span>
<span class="nc" id="L962">            return;</span>
        }

        //If namespace not null , reset Topic without namespace.
<span class="nc bnc" id="L966" title="All 2 branches missed.">        for (MessageExt messageExt : msgList) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if (null != this.defaultLitePullConsumer.getNamespace()) {</span>
<span class="nc" id="L968">                messageExt.setTopic(NamespaceUtil.withoutNamespace(messageExt.getTopic(), this.defaultLitePullConsumer.getNamespace()));</span>
            }
<span class="nc" id="L970">        }</span>

<span class="nc" id="L972">    }</span>

    public void updateConsumeOffset(MessageQueue mq, long offset) {
<span class="nc" id="L975">        checkServiceState();</span>
<span class="nc" id="L976">        this.offsetStore.updateOffset(mq, offset, false);</span>
<span class="nc" id="L977">    }</span>

    @Override
    public String groupName() {
<span class="nc" id="L981">        return this.defaultLitePullConsumer.getConsumerGroup();</span>
    }

    @Override
    public MessageModel messageModel() {
<span class="nc" id="L986">        return this.defaultLitePullConsumer.getMessageModel();</span>
    }

    @Override
    public ConsumeType consumeType() {
<span class="nc" id="L991">        return ConsumeType.CONSUME_ACTIVELY;</span>
    }

    @Override
    public ConsumeFromWhere consumeFromWhere() {
<span class="nc" id="L996">        return ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span>
    }

    @Override
    public Set&lt;SubscriptionData&gt; subscriptions() {
<span class="nc" id="L1001">        Set&lt;SubscriptionData&gt; subSet = new HashSet&lt;SubscriptionData&gt;();</span>

<span class="nc" id="L1003">        subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());</span>

<span class="nc" id="L1005">        return subSet;</span>
    }

    @Override
    public void doRebalance() {
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (this.rebalanceImpl != null) {</span>
<span class="nc" id="L1011">            this.rebalanceImpl.doRebalance(false);</span>
        }
<span class="nc" id="L1013">    }</span>

    @Override
    public void persistConsumerOffset() {
        try {
<span class="nc" id="L1018">            checkServiceState();</span>
<span class="nc" id="L1019">            Set&lt;MessageQueue&gt; mqs = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">            if (this.subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="nc" id="L1021">                Set&lt;MessageQueue&gt; allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();</span>
<span class="nc" id="L1022">                mqs.addAll(allocateMq);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">            } else if (this.subscriptionType == SubscriptionType.ASSIGN) {</span>
<span class="nc" id="L1024">                Set&lt;MessageQueue&gt; assignedMessageQueue = this.assignedMessageQueue.getAssignedMessageQueues();</span>
<span class="nc" id="L1025">                mqs.addAll(assignedMessageQueue);</span>
            }
<span class="nc" id="L1027">            this.offsetStore.persistAll(mqs);</span>
<span class="nc" id="L1028">        } catch (Exception e) {</span>
<span class="nc" id="L1029">            log.error(&quot;Persist consumer offset error for group: {} &quot;, this.defaultLitePullConsumer.getConsumerGroup(), e);</span>
<span class="nc" id="L1030">        }</span>
<span class="nc" id="L1031">    }</span>

    @Override
    public void updateTopicSubscribeInfo(String topic, Set&lt;MessageQueue&gt; info) {
<span class="nc" id="L1035">        Map&lt;String, SubscriptionData&gt; subTable = this.rebalanceImpl.getSubscriptionInner();</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc" id="L1038">                this.rebalanceImpl.getTopicSubscribeInfoTable().put(topic, info);</span>
            }
        }
<span class="nc" id="L1041">    }</span>

    @Override
    public boolean isSubscribeTopicNeedUpdate(String topic) {
<span class="nc" id="L1045">        Map&lt;String, SubscriptionData&gt; subTable = this.rebalanceImpl.getSubscriptionInner();</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);</span>
            }
        }

<span class="nc" id="L1052">        return false;</span>
    }

    @Override
    public boolean isUnitMode() {
<span class="nc" id="L1057">        return this.defaultLitePullConsumer.isUnitMode();</span>
    }

    @Override
    public ConsumerRunningInfo consumerRunningInfo() {
<span class="nc" id="L1062">        ConsumerRunningInfo info = new ConsumerRunningInfo();</span>

<span class="nc" id="L1064">        Properties prop = MixAll.object2Properties(this.defaultLitePullConsumer);</span>
<span class="nc" id="L1065">        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));</span>
<span class="nc" id="L1066">        info.setProperties(prop);</span>

<span class="nc" id="L1068">        info.getSubscriptionSet().addAll(this.subscriptions());</span>
<span class="nc" id="L1069">        return info;</span>
    }

    private void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,
        MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L1074">        this.offsetStore.updateConsumeOffsetToBroker(mq, offset, isOneway);</span>
<span class="nc" id="L1075">    }</span>

    public OffsetStore getOffsetStore() {
<span class="nc" id="L1078">        return offsetStore;</span>
    }

    public DefaultLitePullConsumer getDefaultLitePullConsumer() {
<span class="nc" id="L1082">        return defaultLitePullConsumer;</span>
    }

    public Set&lt;MessageQueue&gt; fetchMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L1086">        checkServiceState();</span>
<span class="nc" id="L1087">        Set&lt;MessageQueue&gt; result = this.mQClientFactory.getMQAdminImpl().fetchSubscribeMessageQueues(topic);</span>
<span class="nc" id="L1088">        return parseMessageQueues(result);</span>
    }

    private synchronized void fetchTopicMessageQueuesAndCompare() throws MQClientException {
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        for (Map.Entry&lt;String, TopicMessageQueueChangeListener&gt; entry : topicMessageQueueChangeListenerMap.entrySet()) {</span>
<span class="nc" id="L1093">            String topic = entry.getKey();</span>
<span class="nc" id="L1094">            TopicMessageQueueChangeListener topicMessageQueueChangeListener = entry.getValue();</span>
<span class="nc" id="L1095">            Set&lt;MessageQueue&gt; oldMessageQueues = messageQueuesForTopic.get(topic);</span>
<span class="nc" id="L1096">            Set&lt;MessageQueue&gt; newMessageQueues = fetchMessageQueues(topic);</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">            boolean isChanged = !isSetEqual(newMessageQueues, oldMessageQueues);</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">            if (isChanged) {</span>
<span class="nc" id="L1099">                messageQueuesForTopic.put(topic, newMessageQueues);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                if (topicMessageQueueChangeListener != null) {</span>
<span class="nc" id="L1101">                    topicMessageQueueChangeListener.onChanged(topic, newMessageQueues);</span>
                }
            }
<span class="nc" id="L1104">        }</span>
<span class="nc" id="L1105">    }</span>

    private boolean isSetEqual(Set&lt;MessageQueue&gt; set1, Set&lt;MessageQueue&gt; set2) {
<span class="nc bnc" id="L1108" title="All 4 branches missed.">        if (set1 == null &amp;&amp; set2 == null) {</span>
<span class="nc" id="L1109">            return true;</span>
        }

<span class="nc bnc" id="L1112" title="All 6 branches missed.">        if (set1 == null || set2 == null || set1.size() != set2.size()</span>
<span class="nc bnc" id="L1113" title="All 4 branches missed.">            || set1.size() == 0 || set2.size() == 0) {</span>
<span class="nc" id="L1114">            return false;</span>
        }

<span class="nc" id="L1117">        Iterator iter = set2.iterator();</span>
<span class="nc" id="L1118">        boolean isEqual = true;</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">            if (!set1.contains(iter.next())) {</span>
<span class="nc" id="L1121">                isEqual = false;</span>
            }
        }
<span class="nc" id="L1124">        return isEqual;</span>
    }

    public synchronized void registerTopicMessageQueueChangeListener(String topic,
        TopicMessageQueueChangeListener listener) throws MQClientException {
<span class="nc bnc" id="L1129" title="All 4 branches missed.">        if (topic == null || listener == null) {</span>
<span class="nc" id="L1130">            throw new MQClientException(&quot;Topic or listener is null&quot;, null);</span>
        }
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (topicMessageQueueChangeListenerMap.containsKey(topic)) {</span>
<span class="nc" id="L1133">            log.warn(&quot;Topic {} had been registered, new listener will overwrite the old one&quot;, topic);</span>
        }
<span class="nc" id="L1135">        topicMessageQueueChangeListenerMap.put(topic, listener);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        if (this.serviceState == ServiceState.RUNNING) {</span>
<span class="nc" id="L1137">            Set&lt;MessageQueue&gt; messageQueues = fetchMessageQueues(topic);</span>
<span class="nc" id="L1138">            messageQueuesForTopic.put(topic, messageQueues);</span>
        }
<span class="nc" id="L1140">    }</span>

    private Set&lt;MessageQueue&gt; parseMessageQueues(Set&lt;MessageQueue&gt; queueSet) {
<span class="nc" id="L1143">        Set&lt;MessageQueue&gt; resultQueues = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        for (MessageQueue messageQueue : queueSet) {</span>
<span class="nc" id="L1145">            String userTopic = NamespaceUtil.withoutNamespace(messageQueue.getTopic(),</span>
<span class="nc" id="L1146">                this.defaultLitePullConsumer.getNamespace());</span>
<span class="nc" id="L1147">            resultQueues.add(new MessageQueue(userTopic, messageQueue.getBrokerName(), messageQueue.getQueueId()));</span>
<span class="nc" id="L1148">        }</span>
<span class="nc" id="L1149">        return resultQueues;</span>
    }

    public class ConsumeRequest {
        private final List&lt;MessageExt&gt; messageExts;
        private final MessageQueue messageQueue;
        private final ProcessQueue processQueue;

        public ConsumeRequest(final List&lt;MessageExt&gt; messageExts, final MessageQueue messageQueue,
<span class="nc" id="L1158">            final ProcessQueue processQueue) {</span>
<span class="nc" id="L1159">            this.messageExts = messageExts;</span>
<span class="nc" id="L1160">            this.messageQueue = messageQueue;</span>
<span class="nc" id="L1161">            this.processQueue = processQueue;</span>
<span class="nc" id="L1162">        }</span>

        public List&lt;MessageExt&gt; getMessageExts() {
<span class="nc" id="L1165">            return messageExts;</span>
        }

        public MessageQueue getMessageQueue() {
<span class="nc" id="L1169">            return messageQueue;</span>
        }

        public ProcessQueue getProcessQueue() {
<span class="nc" id="L1173">            return processQueue;</span>
        }

    }

    public void setPullTimeDelayMillsWhenException(long pullTimeDelayMillsWhenException) {
<span class="nc" id="L1179">        this.pullTimeDelayMillsWhenException = pullTimeDelayMillsWhenException;</span>
<span class="nc" id="L1180">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>