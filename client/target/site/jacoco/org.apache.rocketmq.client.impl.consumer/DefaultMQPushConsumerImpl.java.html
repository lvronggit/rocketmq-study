<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMQPushConsumerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 4.9.5-SNAPSHOT</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.impl.consumer</a> &gt; <span class="el_source">DefaultMQPushConsumerImpl.java</span></div><h1>DefaultMQPushConsumerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.impl.consumer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.rocketmq.client.QueryResult;
import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.PullCallback;
import org.apache.rocketmq.client.consumer.PullResult;
import org.apache.rocketmq.client.consumer.listener.MessageListener;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.hook.ConsumeMessageContext;
import org.apache.rocketmq.client.hook.ConsumeMessageHook;
import org.apache.rocketmq.client.hook.FilterMessageHook;
import org.apache.rocketmq.client.impl.CommunicationMode;
import org.apache.rocketmq.client.impl.MQClientManager;
import org.apache.rocketmq.client.impl.factory.MQClientInstance;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.client.stat.ConsumerStatsManager;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.ServiceState;
import org.apache.rocketmq.common.UtilAll;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.filter.FilterAPI;
import org.apache.rocketmq.common.help.FAQUrl;
import org.apache.rocketmq.common.protocol.NamespaceUtil;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageAccessor;
import org.apache.rocketmq.common.message.MessageConst;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.body.ConsumeStatus;
import org.apache.rocketmq.common.protocol.body.ConsumerRunningInfo;
import org.apache.rocketmq.common.protocol.body.ProcessQueueInfo;
import org.apache.rocketmq.common.protocol.body.QueueTimeSpan;
import org.apache.rocketmq.common.protocol.heartbeat.ConsumeType;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;
import org.apache.rocketmq.common.protocol.route.BrokerData;
import org.apache.rocketmq.common.protocol.route.TopicRouteData;
import org.apache.rocketmq.common.sysflag.PullSysFlag;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.apache.rocketmq.remoting.exception.RemotingException;

public class DefaultMQPushConsumerImpl implements MQConsumerInner {
    /**
     * Delay some time when exception occur
     */
<span class="nc" id="L87">    private long pullTimeDelayMillsWhenException = 3000;</span>
    /**
     * Flow control interval
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = 50;
    /**
     * Delay some time when suspend pull service
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = 1000;
    private static final long BROKER_SUSPEND_MAX_TIME_MILLIS = 1000 * 15;
    private static final long CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = 1000 * 30;
<span class="nc" id="L98">    private final InternalLogger log = ClientLogger.getLog();</span>
    private final DefaultMQPushConsumer defaultMQPushConsumer;
<span class="nc" id="L100">    private final RebalanceImpl rebalanceImpl = new RebalancePushImpl(this);</span>
<span class="nc" id="L101">    private final ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = new ArrayList&lt;FilterMessageHook&gt;();</span>
<span class="nc" id="L102">    private final long consumerStartTimestamp = System.currentTimeMillis();</span>
<span class="nc" id="L103">    private final ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = new ArrayList&lt;ConsumeMessageHook&gt;();</span>
    private final RPCHook rpcHook;
<span class="nc" id="L105">    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;</span>
    private MQClientInstance mQClientFactory;
    private PullAPIWrapper pullAPIWrapper;
<span class="nc" id="L108">    private volatile boolean pause = false;</span>
<span class="nc" id="L109">    private boolean consumeOrderly = false;</span>
    private MessageListener messageListenerInner;
    private OffsetStore offsetStore;
    private ConsumeMessageService consumeMessageService;
<span class="nc" id="L113">    private long queueFlowControlTimes = 0;</span>
<span class="nc" id="L114">    private long queueMaxSpanFlowControlTimes = 0;</span>

<span class="nc" id="L116">    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {</span>
<span class="nc" id="L117">        this.defaultMQPushConsumer = defaultMQPushConsumer;</span>
<span class="nc" id="L118">        this.rpcHook = rpcHook;</span>
<span class="nc" id="L119">        this.pullTimeDelayMillsWhenException = defaultMQPushConsumer.getPullTimeDelayMillsWhenException();</span>
<span class="nc" id="L120">    }</span>

    public void registerFilterMessageHook(final FilterMessageHook hook) {
<span class="nc" id="L123">        this.filterMessageHookList.add(hook);</span>
<span class="nc" id="L124">        log.info(&quot;register FilterMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L125">    }</span>

    public boolean hasHook() {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        return !this.consumeMessageHookList.isEmpty();</span>
    }

    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {
<span class="nc" id="L132">        this.consumeMessageHookList.add(hook);</span>
<span class="nc" id="L133">        log.info(&quot;register consumeMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L134">    }</span>

    public void executeHookBefore(final ConsumeMessageContext context) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L140">                    hook.consumeMessageBefore(context);</span>
<span class="nc" id="L141">                } catch (Throwable e) {</span>
<span class="nc" id="L142">                }</span>
<span class="nc" id="L143">            }</span>
        }
<span class="nc" id="L145">    }</span>

    public void executeHookAfter(final ConsumeMessageContext context) {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L151">                    hook.consumeMessageAfter(context);</span>
<span class="nc" id="L152">                } catch (Throwable e) {</span>
<span class="nc" id="L153">                }</span>
<span class="nc" id="L154">            }</span>
        }
<span class="nc" id="L156">    }</span>

    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
<span class="nc" id="L159">        createTopic(key, newTopic, queueNum, 0);</span>
<span class="nc" id="L160">    }</span>

    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
<span class="nc" id="L163">        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag);</span>
<span class="nc" id="L164">    }</span>

    public Set&lt;MessageQueue&gt; fetchSubscribeMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L167">        Set&lt;MessageQueue&gt; result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L169">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="nc" id="L170">            result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
        }

<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L174">            throw new MQClientException(&quot;The topic[&quot; + topic + &quot;] not exist&quot;, null);</span>
        }

<span class="nc" id="L177">        return parseSubscribeMessageQueues(result);</span>
    }

    public Set&lt;MessageQueue&gt; parseSubscribeMessageQueues(Set&lt;MessageQueue&gt; messageQueueList) {
<span class="nc" id="L181">        Set&lt;MessageQueue&gt; resultQueues = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        for (MessageQueue queue : messageQueueList) {</span>
<span class="nc" id="L183">            String userTopic = NamespaceUtil.withoutNamespace(queue.getTopic(), this.defaultMQPushConsumer.getNamespace());</span>
<span class="nc" id="L184">            resultQueues.add(new MessageQueue(userTopic, queue.getBrokerName(), queue.getQueueId()));</span>
<span class="nc" id="L185">        }</span>

<span class="nc" id="L187">        return resultQueues;</span>
    }

    public DefaultMQPushConsumer getDefaultMQPushConsumer() {
<span class="nc" id="L191">        return defaultMQPushConsumer;</span>
    }

    public long earliestMsgStoreTime(MessageQueue mq) throws MQClientException {
<span class="nc" id="L195">        return this.mQClientFactory.getMQAdminImpl().earliestMsgStoreTime(mq);</span>
    }

    public long maxOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L199">        return this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span>
    }

    public long minOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L203">        return this.mQClientFactory.getMQAdminImpl().minOffset(mq);</span>
    }

    public OffsetStore getOffsetStore() {
<span class="nc" id="L207">        return offsetStore;</span>
    }

    public void setOffsetStore(OffsetStore offsetStore) {
<span class="nc" id="L211">        this.offsetStore = offsetStore;</span>
<span class="nc" id="L212">    }</span>

    public void pullMessage(final PullRequest pullRequest) {
<span class="nc" id="L215">        final ProcessQueue processQueue = pullRequest.getProcessQueue();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (processQueue.isDropped()) {</span>
<span class="nc" id="L217">            log.info(&quot;the pull request[{}] is dropped.&quot;, pullRequest.toString());</span>
<span class="nc" id="L218">            return;</span>
        }

<span class="nc" id="L221">        pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span>

        try {
<span class="nc" id="L224">            this.makeSureStateOK();</span>
<span class="nc" id="L225">        } catch (MQClientException e) {</span>
<span class="nc" id="L226">            log.warn(&quot;pullMessage exception, consumer state not ok&quot;, e);</span>
<span class="nc" id="L227">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L228">            return;</span>
<span class="nc" id="L229">        }</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (this.isPause()) {</span>
<span class="nc" id="L232">            log.warn(&quot;consumer was paused, execute pull request later. instanceName={}, group={}&quot;, this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L233">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span>
<span class="nc" id="L234">            return;</span>
        }

<span class="nc" id="L237">        long cachedMessageCount = processQueue.getMsgCount().get();</span>
<span class="nc" id="L238">        long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) {</span>
<span class="nc" id="L241">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L243">                log.warn(</span>
                    &quot;the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L245">                    this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span>
            }
<span class="nc" id="L247">            return;</span>
        }

<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (cachedMessageSizeInMiB &gt; this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {</span>
<span class="nc" id="L251">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L253">                log.warn(</span>
                    &quot;the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L255">                    this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span>
            }
<span class="nc" id="L257">            return;</span>
        }

<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (!this.consumeOrderly) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {</span>
<span class="nc" id="L262">                this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L264">                    log.warn(</span>
                        &quot;the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L266">                        processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span>
<span class="nc" id="L267">                        pullRequest, queueMaxSpanFlowControlTimes);</span>
                }
<span class="nc" id="L269">                return;</span>
            }
        } else {
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (processQueue.isLocked()) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                if (!pullRequest.isPreviouslyLocked()) {</span>
<span class="nc" id="L274">                    long offset = -1L;</span>
                    try {
<span class="nc" id="L276">                        offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue());</span>
<span class="nc" id="L277">                    } catch (Exception e) {</span>
<span class="nc" id="L278">                        this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L279">                        log.error(&quot;Failed to compute pull offset, pullResult: {}&quot;, pullRequest, e);</span>
<span class="nc" id="L280">                        return;</span>
<span class="nc" id="L281">                    }</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                    boolean brokerBusy = offset &lt; pullRequest.getNextOffset();</span>
<span class="nc" id="L283">                    log.info(&quot;the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}&quot;,</span>
<span class="nc" id="L284">                        pullRequest, offset, brokerBusy);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                    if (brokerBusy) {</span>
<span class="nc" id="L286">                        log.info(&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}&quot;,</span>
<span class="nc" id="L287">                            pullRequest, offset);</span>
                    }

<span class="nc" id="L290">                    pullRequest.setPreviouslyLocked(true);</span>
<span class="nc" id="L291">                    pullRequest.setNextOffset(offset);</span>
<span class="nc" id="L292">                }</span>
            } else {
<span class="nc" id="L294">                this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L295">                log.info(&quot;pull message later because not locked in broker, {}&quot;, pullRequest);</span>
<span class="nc" id="L296">                return;</span>
            }
        }

<span class="nc" id="L300">        final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (null == subscriptionData) {</span>
<span class="nc" id="L302">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L303">            log.warn(&quot;find the consumer's subscription failed, {}&quot;, pullRequest);</span>
<span class="nc" id="L304">            return;</span>
        }

<span class="nc" id="L307">        final long beginTimestamp = System.currentTimeMillis();</span>

<span class="nc" id="L309">        PullCallback pullCallback = new PullCallback() {</span>
            @Override
            public void onSuccess(PullResult pullResult) {
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (pullResult != null) {</span>
<span class="nc" id="L313">                    pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span>
                        subscriptionData);

<span class="nc bnc" id="L316" title="All 4 branches missed.">                    switch (pullResult.getPullStatus()) {</span>
                        case FOUND:
<span class="nc" id="L318">                            long prevRequestOffset = pullRequest.getNextOffset();</span>
<span class="nc" id="L319">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>
<span class="nc" id="L320">                            long pullRT = System.currentTimeMillis() - beginTimestamp;</span>
<span class="nc" id="L321">                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span>
<span class="nc" id="L322">                                pullRequest.getMessageQueue().getTopic(), pullRT);</span>

<span class="nc" id="L324">                            long firstMsgOffset = Long.MAX_VALUE;</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">                            if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {</span>
<span class="nc" id="L326">                                DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                            } else {
<span class="nc" id="L328">                                firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();</span>

<span class="nc" id="L330">                                DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span>
<span class="nc" id="L331">                                    pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span>

<span class="nc" id="L333">                                boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span>
<span class="nc" id="L334">                                DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(</span>
<span class="nc" id="L335">                                    pullResult.getMsgFoundList(),</span>
                                    processQueue,
<span class="nc" id="L337">                                    pullRequest.getMessageQueue(),</span>
                                    dispatchToConsume);

<span class="nc bnc" id="L340" title="All 2 branches missed.">                                if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) {</span>
<span class="nc" id="L341">                                    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,</span>
<span class="nc" id="L342">                                        DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());</span>
                                } else {
<span class="nc" id="L344">                                    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                                }
                            }

<span class="nc bnc" id="L348" title="All 4 branches missed.">                            if (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span>
                                || firstMsgOffset &lt; prevRequestOffset) {
<span class="nc" id="L350">                                log.warn(</span>
                                    &quot;[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}&quot;,
<span class="nc" id="L352">                                    pullResult.getNextBeginOffset(),</span>
<span class="nc" id="L353">                                    firstMsgOffset,</span>
<span class="nc" id="L354">                                    prevRequestOffset);</span>
                            }

                            break;
                        case NO_NEW_MSG:
                        case NO_MATCHED_MSG:
<span class="nc" id="L360">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L362">                            DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);</span>

<span class="nc" id="L364">                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L365">                            break;</span>
                        case OFFSET_ILLEGAL:
<span class="nc" id="L367">                            log.warn(&quot;the pull request offset illegal, {} {}&quot;,</span>
<span class="nc" id="L368">                                pullRequest.toString(), pullResult.toString());</span>
<span class="nc" id="L369">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L371">                            pullRequest.getProcessQueue().setDropped(true);</span>
<span class="nc" id="L372">                            DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {</span>

                                @Override
                                public void run() {
                                    try {
<span class="nc" id="L377">                                        DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span>
<span class="nc" id="L378">                                            pullRequest.getNextOffset(), false);</span>

<span class="nc" id="L380">                                        DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());</span>

<span class="nc" id="L382">                                        DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span>

<span class="nc" id="L384">                                        log.warn(&quot;fix the pull request offset, {}&quot;, pullRequest);</span>
<span class="nc" id="L385">                                    } catch (Throwable e) {</span>
<span class="nc" id="L386">                                        log.error(&quot;executeTaskLater Exception&quot;, e);</span>
<span class="nc" id="L387">                                    }</span>
<span class="nc" id="L388">                                }</span>
                            }, 10000);
<span class="nc" id="L390">                            break;</span>
                        default:
                            break;
                    }
                }
<span class="nc" id="L395">            }</span>

            @Override
            public void onException(Throwable e) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {</span>
<span class="nc" id="L400">                    log.warn(&quot;execute the pull request exception&quot;, e);</span>
                }

<span class="nc" id="L403">                DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L404">            }</span>
        };

<span class="nc" id="L407">        boolean commitOffsetEnable = false;</span>
<span class="nc" id="L408">        long commitOffsetValue = 0L;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="nc" id="L410">            commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (commitOffsetValue &gt; 0) {</span>
<span class="nc" id="L412">                commitOffsetEnable = true;</span>
            }
        }

<span class="nc" id="L416">        String subExpression = null;</span>
<span class="nc" id="L417">        boolean classFilter = false;</span>
<span class="nc" id="L418">        SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (sd != null) {</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">            if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) {</span>
<span class="nc" id="L421">                subExpression = sd.getSubString();</span>
            }

<span class="nc" id="L424">            classFilter = sd.isClassFilterMode();</span>
        }

<span class="nc bnc" id="L427" title="All 2 branches missed.">        int sysFlag = PullSysFlag.buildSysFlag(</span>
            commitOffsetEnable, // commitOffset
            true, // suspend
            subExpression != null, // subscription
            classFilter // class filter
        );
        try {
<span class="nc" id="L434">            this.pullAPIWrapper.pullKernelImpl(</span>
<span class="nc" id="L435">                pullRequest.getMessageQueue(),</span>
                subExpression,
<span class="nc" id="L437">                subscriptionData.getExpressionType(),</span>
<span class="nc" id="L438">                subscriptionData.getSubVersion(),</span>
<span class="nc" id="L439">                pullRequest.getNextOffset(),</span>
<span class="nc" id="L440">                this.defaultMQPushConsumer.getPullBatchSize(),</span>
                sysFlag,
                commitOffsetValue,
                BROKER_SUSPEND_MAX_TIME_MILLIS,
                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,
                CommunicationMode.ASYNC,
                pullCallback
            );
<span class="nc" id="L448">        } catch (Exception e) {</span>
<span class="nc" id="L449">            log.error(&quot;pullKernelImpl exception&quot;, e);</span>
<span class="nc" id="L450">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L451">        }</span>
<span class="nc" id="L452">    }</span>

    private void makeSureStateOK() throws MQClientException {
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (this.serviceState != ServiceState.RUNNING) {</span>
<span class="nc" id="L456">            throw new MQClientException(&quot;The consumer service state not OK, &quot;</span>
                + this.serviceState
<span class="nc" id="L458">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                null);
        }
<span class="nc" id="L461">    }</span>

    private void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {
<span class="nc" id="L464">        this.mQClientFactory.getPullMessageService().executePullRequestLater(pullRequest, timeDelay);</span>
<span class="nc" id="L465">    }</span>

    public boolean isPause() {
<span class="nc" id="L468">        return pause;</span>
    }

    public void setPause(boolean pause) {
<span class="nc" id="L472">        this.pause = pause;</span>
<span class="nc" id="L473">    }</span>

    public ConsumerStatsManager getConsumerStatsManager() {
<span class="nc" id="L476">        return this.mQClientFactory.getConsumerStatsManager();</span>
    }

    public void executePullRequestImmediately(final PullRequest pullRequest) {
<span class="nc" id="L480">        this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L481">    }</span>

    private void correctTagsOffset(final PullRequest pullRequest) {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {</span>
<span class="nc" id="L485">            this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);</span>
        }
<span class="nc" id="L487">    }</span>

    public void executeTaskLater(final Runnable r, final long timeDelay) {
<span class="nc" id="L490">        this.mQClientFactory.getPullMessageService().executeTaskLater(r, timeDelay);</span>
<span class="nc" id="L491">    }</span>

    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
        throws MQClientException, InterruptedException {
<span class="nc" id="L495">        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);</span>
    }

    public MessageExt queryMessageByUniqKey(String topic, String uniqKey) throws MQClientException,
        InterruptedException {
<span class="nc" id="L500">        return this.mQClientFactory.getMQAdminImpl().queryMessageByUniqKey(topic, uniqKey);</span>
    }

    public void registerMessageListener(MessageListener messageListener) {
<span class="nc" id="L504">        this.messageListenerInner = messageListener;</span>
<span class="nc" id="L505">    }</span>

    public void resume() {
<span class="nc" id="L508">        this.pause = false;</span>
<span class="nc" id="L509">        doRebalance();</span>
<span class="nc" id="L510">        log.info(&quot;resume this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L511">    }</span>

    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
        try {
<span class="nc bnc" id="L516" title="All 2 branches missed.">            String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)</span>
<span class="nc" id="L517">                : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span>
<span class="nc" id="L518">            this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, brokerName, msg,</span>
<span class="nc" id="L519">                this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());</span>
<span class="nc" id="L520">        } catch (Exception e) {</span>
<span class="nc" id="L521">            log.error(&quot;sendMessageBack Exception, &quot; + this.defaultMQPushConsumer.getConsumerGroup(), e);</span>

<span class="nc" id="L523">            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span>

<span class="nc" id="L525">            String originMsgId = MessageAccessor.getOriginMessageId(msg);</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span>

<span class="nc" id="L528">            newMsg.setFlag(msg.getFlag());</span>
<span class="nc" id="L529">            MessageAccessor.setProperties(newMsg, msg.getProperties());</span>
<span class="nc" id="L530">            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span>
<span class="nc" id="L531">            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));</span>
<span class="nc" id="L532">            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span>
<span class="nc" id="L533">            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);</span>
<span class="nc" id="L534">            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());</span>

<span class="nc" id="L536">            this.mQClientFactory.getDefaultMQProducer().send(newMsg);</span>
        } finally {
<span class="nc" id="L538">            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));</span>
        }
<span class="nc" id="L540">    }</span>

    private int getMaxReconsumeTimes() {
        // default reconsume times: 16
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {</span>
<span class="nc" id="L545">            return 16;</span>
        } else {
<span class="nc" id="L547">            return this.defaultMQPushConsumer.getMaxReconsumeTimes();</span>
        }
    }

    public void shutdown() {
<span class="nc" id="L552">        shutdown(0);</span>
<span class="nc" id="L553">    }</span>

    public synchronized void shutdown(long awaitTerminateMillis) {
<span class="nc bnc" id="L556" title="All 4 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L558">                break;</span>
            case RUNNING:
<span class="nc" id="L560">                this.consumeMessageService.shutdown(awaitTerminateMillis);</span>
<span class="nc" id="L561">                this.persistConsumerOffset();</span>
<span class="nc" id="L562">                this.mQClientFactory.unregisterConsumer(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L563">                this.mQClientFactory.shutdown();</span>
<span class="nc" id="L564">                log.info(&quot;the consumer [{}] shutdown OK&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L565">                this.rebalanceImpl.destroy();</span>
<span class="nc" id="L566">                this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span>
<span class="nc" id="L567">                break;</span>
            case SHUTDOWN_ALREADY:
<span class="nc" id="L569">                break;</span>
            default:
                break;
        }
<span class="nc" id="L573">    }</span>

    public synchronized void start() throws MQClientException {
<span class="nc bnc" id="L576" title="All 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L578">                log.info(&quot;the consumer [{}] start beginning. messageModel={}, isUnitMode={}&quot;, this.defaultMQPushConsumer.getConsumerGroup(),</span>
<span class="nc" id="L579">                    this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());</span>
<span class="nc" id="L580">                this.serviceState = ServiceState.START_FAILED;</span>

<span class="nc" id="L582">                this.checkConfig();</span>

<span class="nc" id="L584">                this.copySubscription();</span>

<span class="nc bnc" id="L586" title="All 2 branches missed.">                if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {</span>
<span class="nc" id="L587">                    this.defaultMQPushConsumer.changeInstanceNameToPID();</span>
                }

<span class="nc" id="L590">                this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);</span>

<span class="nc" id="L592">                this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L593">                this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());</span>
<span class="nc" id="L594">                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span>
<span class="nc" id="L595">                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span>

<span class="nc" id="L597">                this.pullAPIWrapper = new PullAPIWrapper(</span>
                    mQClientFactory,
<span class="nc" id="L599">                    this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span>
<span class="nc" id="L600">                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span>

<span class="nc bnc" id="L602" title="All 2 branches missed.">                if (this.defaultMQPushConsumer.getOffsetStore() != null) {</span>
<span class="nc" id="L603">                    this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();</span>
                } else {
<span class="nc bnc" id="L605" title="All 3 branches missed.">                    switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                        case BROADCASTING:
<span class="nc" id="L607">                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L608">                            break;</span>
                        case CLUSTERING:
<span class="nc" id="L610">                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L611">                            break;</span>
                        default:
                            break;
                    }
<span class="nc" id="L615">                    this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);</span>
                }
<span class="nc" id="L617">                this.offsetStore.load();</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">                if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {</span>
<span class="nc" id="L620">                    this.consumeOrderly = true;</span>
<span class="nc" id="L621">                    this.consumeMessageService =</span>
<span class="nc" id="L622">                        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {</span>
<span class="nc" id="L624">                    this.consumeOrderly = false;</span>
<span class="nc" id="L625">                    this.consumeMessageService =</span>
<span class="nc" id="L626">                        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());</span>
                }

<span class="nc" id="L629">                this.consumeMessageService.start();</span>

<span class="nc" id="L631">                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                if (!registerOK) {</span>
<span class="nc" id="L633">                    this.serviceState = ServiceState.CREATE_JUST;</span>
<span class="nc" id="L634">                    this.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown());</span>
<span class="nc" id="L635">                    throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPushConsumer.getConsumerGroup()</span>
<span class="nc" id="L636">                        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span>
                        null);
                }

<span class="nc" id="L640">                mQClientFactory.start();</span>
<span class="nc" id="L641">                log.info(&quot;the consumer [{}] start OK.&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L642">                this.serviceState = ServiceState.RUNNING;</span>
<span class="nc" id="L643">                break;</span>
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
<span class="nc" id="L647">                throw new MQClientException(&quot;The PushConsumer service state not OK, maybe started once, &quot;</span>
                    + this.serviceState
<span class="nc" id="L649">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                    null);
            default:
                break;
        }

<span class="nc" id="L655">        this.updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
<span class="nc" id="L656">        this.mQClientFactory.checkClientInBroker();</span>
<span class="nc" id="L657">        this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
<span class="nc" id="L658">        this.mQClientFactory.rebalanceImmediately();</span>
<span class="nc" id="L659">    }</span>

    private void checkConfig() throws MQClientException {
<span class="nc" id="L662">        Validators.checkGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>

<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumerGroup()) {</span>
<span class="nc" id="L665">            throw new MQClientException(</span>
                &quot;consumerGroup is null&quot;
<span class="nc" id="L667">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {</span>
<span class="nc" id="L672">            throw new MQClientException(</span>
                &quot;consumerGroup can not equal &quot;
                    + MixAll.DEFAULT_CONSUMER_GROUP
                    + &quot;, please specify another one.&quot;
<span class="nc" id="L676">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="nc" id="L681">            throw new MQClientException(</span>
                &quot;messageModel is null&quot;
<span class="nc" id="L683">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumeFromWhere()) {</span>
<span class="nc" id="L688">            throw new MQClientException(</span>
                &quot;consumeFromWhere is null&quot;
<span class="nc" id="L690">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc" id="L694">        Date dt = UtilAll.parseDate(this.defaultMQPushConsumer.getConsumeTimestamp(), UtilAll.YYYYMMDDHHMMSS);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (null == dt) {</span>
<span class="nc" id="L696">            throw new MQClientException(</span>
                &quot;consumeTimestamp is invalid, the valid format is yyyyMMddHHmmss,but received &quot;
<span class="nc" id="L698">                    + this.defaultMQPushConsumer.getConsumeTimestamp()</span>
<span class="nc" id="L699">                    + &quot; &quot; + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL), null);</span>
        }

        // allocateMessageQueueStrategy
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (null == this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()) {</span>
<span class="nc" id="L704">            throw new MQClientException(</span>
                &quot;allocateMessageQueueStrategy is null&quot;
<span class="nc" id="L706">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // subscription
<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (null == this.defaultMQPushConsumer.getSubscription()) {</span>
<span class="nc" id="L712">            throw new MQClientException(</span>
                &quot;subscription is null&quot;
<span class="nc" id="L714">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // messageListener
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageListener()) {</span>
<span class="nc" id="L720">            throw new MQClientException(</span>
                &quot;messageListener is null&quot;
<span class="nc" id="L722">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc" id="L726">        boolean orderly = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerOrderly;</span>
<span class="nc" id="L727">        boolean concurrently = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerConcurrently;</span>
<span class="nc bnc" id="L728" title="All 4 branches missed.">        if (!orderly &amp;&amp; !concurrently) {</span>
<span class="nc" id="L729">            throw new MQClientException(</span>
                &quot;messageListener must be instanceof MessageListenerOrderly or MessageListenerConcurrently&quot;
<span class="nc" id="L731">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMin
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMin() &lt; 1</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeThreadMin() &gt; 1000) {</span>
<span class="nc" id="L738">            throw new MQClientException(</span>
                &quot;consumeThreadMin Out of range [1, 1000]&quot;
<span class="nc" id="L740">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMax
<span class="nc bnc" id="L745" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMax() &lt; 1 || this.defaultMQPushConsumer.getConsumeThreadMax() &gt; 1000) {</span>
<span class="nc" id="L746">            throw new MQClientException(</span>
                &quot;consumeThreadMax Out of range [1, 1000]&quot;
<span class="nc" id="L748">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMin can't be larger than consumeThreadMax
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMin() &gt; this.defaultMQPushConsumer.getConsumeThreadMax()) {</span>
<span class="nc" id="L754">            throw new MQClientException(</span>
<span class="nc" id="L755">                &quot;consumeThreadMin (&quot; + this.defaultMQPushConsumer.getConsumeThreadMin() + &quot;) &quot;</span>
<span class="nc" id="L756">                    + &quot;is larger than consumeThreadMax (&quot; + this.defaultMQPushConsumer.getConsumeThreadMax() + &quot;)&quot;,</span>
                null);
        }

        // consumeConcurrentlyMaxSpan
<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &lt; 1</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &gt; 65535) {</span>
<span class="nc" id="L763">            throw new MQClientException(</span>
                &quot;consumeConcurrentlyMaxSpan Out of range [1, 65535]&quot;
<span class="nc" id="L765">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullThresholdForQueue
<span class="nc bnc" id="L770" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdForQueue() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdForQueue() &gt; 65535) {</span>
<span class="nc" id="L771">            throw new MQClientException(</span>
                &quot;pullThresholdForQueue Out of range [1, 65535]&quot;
<span class="nc" id="L773">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullThresholdForTopic
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdForTopic() != -1) {</span>
<span class="nc bnc" id="L779" title="All 4 branches missed.">            if (this.defaultMQPushConsumer.getPullThresholdForTopic() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdForTopic() &gt; 6553500) {</span>
<span class="nc" id="L780">                throw new MQClientException(</span>
                    &quot;pullThresholdForTopic Out of range [1, 6553500]&quot;
<span class="nc" id="L782">                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                    null);
            }
        }

        // pullThresholdSizeForQueue
<span class="nc bnc" id="L788" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdSizeForQueue() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdSizeForQueue() &gt; 1024) {</span>
<span class="nc" id="L789">            throw new MQClientException(</span>
                &quot;pullThresholdSizeForQueue Out of range [1, 1024]&quot;
<span class="nc" id="L791">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() != -1) {</span>
            // pullThresholdSizeForTopic
<span class="nc bnc" id="L797" title="All 4 branches missed.">            if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdSizeForTopic() &gt; 102400) {</span>
<span class="nc" id="L798">                throw new MQClientException(</span>
                    &quot;pullThresholdSizeForTopic Out of range [1, 102400]&quot;
<span class="nc" id="L800">                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                    null);
            }
        }

        // pullInterval
<span class="nc bnc" id="L806" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullInterval() &lt; 0 || this.defaultMQPushConsumer.getPullInterval() &gt; 65535) {</span>
<span class="nc" id="L807">            throw new MQClientException(</span>
                &quot;pullInterval Out of range [0, 65535]&quot;
<span class="nc" id="L809">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeMessageBatchMaxSize
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &lt; 1</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &gt; 1024) {</span>
<span class="nc" id="L816">            throw new MQClientException(</span>
                &quot;consumeMessageBatchMaxSize Out of range [1, 1024]&quot;
<span class="nc" id="L818">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullBatchSize
<span class="nc bnc" id="L823" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullBatchSize() &lt; 1 || this.defaultMQPushConsumer.getPullBatchSize() &gt; 1024) {</span>
<span class="nc" id="L824">            throw new MQClientException(</span>
                &quot;pullBatchSize Out of range [1, 1024]&quot;
<span class="nc" id="L826">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }
<span class="nc" id="L829">    }</span>

    private void copySubscription() throws MQClientException {
        try {
<span class="nc" id="L833">            Map&lt;String, String&gt; sub = this.defaultMQPushConsumer.getSubscription();</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">            if (sub != null) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">                for (final Map.Entry&lt;String, String&gt; entry : sub.entrySet()) {</span>
<span class="nc" id="L836">                    final String topic = entry.getKey();</span>
<span class="nc" id="L837">                    final String subString = entry.getValue();</span>
<span class="nc" id="L838">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subString);</span>
<span class="nc" id="L839">                    this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L840">                }</span>
            }

<span class="nc bnc" id="L843" title="All 2 branches missed.">            if (null == this.messageListenerInner) {</span>
<span class="nc" id="L844">                this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();</span>
            }

<span class="nc bnc" id="L847" title="All 3 branches missed.">            switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                case BROADCASTING:
<span class="nc" id="L849">                    break;</span>
                case CLUSTERING:
<span class="nc" id="L851">                    final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L852">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(retryTopic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L853">                    this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span>
<span class="nc" id="L854">                    break;</span>
                default:
                    break;
            }
<span class="nc" id="L858">        } catch (Exception e) {</span>
<span class="nc" id="L859">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L860">        }</span>
<span class="nc" id="L861">    }</span>

    public MessageListener getMessageListenerInner() {
<span class="nc" id="L864">        return messageListenerInner;</span>
    }

    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {
<span class="nc" id="L868">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">            for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) {</span>
<span class="nc" id="L871">                final String topic = entry.getKey();</span>
<span class="nc" id="L872">                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="nc" id="L873">            }</span>
        }
<span class="nc" id="L875">    }</span>

    public ConcurrentMap&lt;String, SubscriptionData&gt; getSubscriptionInner() {
<span class="nc" id="L878">        return this.rebalanceImpl.getSubscriptionInner();</span>
    }

    public void subscribe(String topic, String subExpression) throws MQClientException {
        try {
<span class="nc" id="L883">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression);</span>
<span class="nc" id="L884">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L886">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }
<span class="nc" id="L888">        } catch (Exception e) {</span>
<span class="nc" id="L889">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L890">        }</span>
<span class="nc" id="L891">    }</span>

    public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {
        try {
<span class="nc" id="L895">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, &quot;*&quot;);</span>
<span class="nc" id="L896">            subscriptionData.setSubString(fullClassName);</span>
<span class="nc" id="L897">            subscriptionData.setClassFilterMode(true);</span>
<span class="nc" id="L898">            subscriptionData.setFilterClassSource(filterClassSource);</span>
<span class="nc" id="L899">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L901">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }

<span class="nc" id="L904">        } catch (Exception e) {</span>
<span class="nc" id="L905">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L906">        }</span>
<span class="nc" id="L907">    }</span>

    public void subscribe(final String topic, final MessageSelector messageSelector) throws MQClientException {
        try {
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (messageSelector == null) {</span>
<span class="nc" id="L912">                subscribe(topic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L913">                return;</span>
            }

<span class="nc" id="L916">            SubscriptionData subscriptionData = FilterAPI.build(topic,</span>
<span class="nc" id="L917">                messageSelector.getExpression(), messageSelector.getExpressionType());</span>

<span class="nc" id="L919">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L921">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }
<span class="nc" id="L923">        } catch (Exception e) {</span>
<span class="nc" id="L924">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L925">        }</span>
<span class="nc" id="L926">    }</span>

    public void suspend() {
<span class="nc" id="L929">        this.pause = true;</span>
<span class="nc" id="L930">        log.info(&quot;suspend this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L931">    }</span>

    public void unsubscribe(String topic) {
<span class="nc" id="L934">        this.rebalanceImpl.getSubscriptionInner().remove(topic);</span>
<span class="nc" id="L935">    }</span>

    public void updateConsumeOffset(MessageQueue mq, long offset) {
<span class="nc" id="L938">        this.offsetStore.updateOffset(mq, offset, false);</span>
<span class="nc" id="L939">    }</span>

    public void updateCorePoolSize(int corePoolSize) {
<span class="nc" id="L942">        this.consumeMessageService.updateCorePoolSize(corePoolSize);</span>
<span class="nc" id="L943">    }</span>

    public MessageExt viewMessage(String msgId)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L947">        return this.mQClientFactory.getMQAdminImpl().viewMessage(msgId);</span>
    }

    public RebalanceImpl getRebalanceImpl() {
<span class="nc" id="L951">        return rebalanceImpl;</span>
    }

    public boolean isConsumeOrderly() {
<span class="nc" id="L955">        return consumeOrderly;</span>
    }

    public void setConsumeOrderly(boolean consumeOrderly) {
<span class="nc" id="L959">        this.consumeOrderly = consumeOrderly;</span>
<span class="nc" id="L960">    }</span>

    public void resetOffsetByTimeStamp(long timeStamp) throws MQClientException {
<span class="nc bnc" id="L963" title="All 2 branches missed.">        for (String topic : rebalanceImpl.getSubscriptionInner().keySet()) {</span>
<span class="nc" id="L964">            Set&lt;MessageQueue&gt; mqs = rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">            if (CollectionUtils.isNotEmpty(mqs)) {</span>
<span class="nc" id="L966">                Map&lt;MessageQueue, Long&gt; offsetTable = new HashMap&lt;MessageQueue, Long&gt;(mqs.size(), 1);</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                for (MessageQueue mq : mqs) {</span>
<span class="nc" id="L968">                    long offset = searchOffset(mq, timeStamp);</span>
<span class="nc" id="L969">                    offsetTable.put(mq, offset);</span>
<span class="nc" id="L970">                }</span>
<span class="nc" id="L971">                this.mQClientFactory.resetOffset(topic, groupName(), offsetTable);</span>
            }
<span class="nc" id="L973">        }</span>
<span class="nc" id="L974">    }</span>

    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="nc" id="L977">        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span>
    }

    @Override
    public String groupName() {
<span class="nc" id="L982">        return this.defaultMQPushConsumer.getConsumerGroup();</span>
    }

    @Override
    public MessageModel messageModel() {
<span class="nc" id="L987">        return this.defaultMQPushConsumer.getMessageModel();</span>
    }

    @Override
    public ConsumeType consumeType() {
<span class="nc" id="L992">        return ConsumeType.CONSUME_PASSIVELY;</span>
    }

    @Override
    public ConsumeFromWhere consumeFromWhere() {
<span class="nc" id="L997">        return this.defaultMQPushConsumer.getConsumeFromWhere();</span>
    }

    @Override
    public Set&lt;SubscriptionData&gt; subscriptions() {
<span class="nc" id="L1002">        return new HashSet&lt;SubscriptionData&gt;(this.rebalanceImpl.getSubscriptionInner().values());</span>
    }

    @Override
    public void doRebalance() {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">        if (!this.pause) {</span>
<span class="nc" id="L1008">            this.rebalanceImpl.doRebalance(this.isConsumeOrderly());</span>
        }
<span class="nc" id="L1010">    }</span>

    @Override
    public void persistConsumerOffset() {
        try {
<span class="nc" id="L1015">            this.makeSureStateOK();</span>
<span class="nc" id="L1016">            Set&lt;MessageQueue&gt; mqs = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc" id="L1017">            Set&lt;MessageQueue&gt; allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();</span>
<span class="nc" id="L1018">            mqs.addAll(allocateMq);</span>

<span class="nc" id="L1020">            this.offsetStore.persistAll(mqs);</span>
<span class="nc" id="L1021">        } catch (Exception e) {</span>
<span class="nc" id="L1022">            log.error(&quot;group: &quot; + this.defaultMQPushConsumer.getConsumerGroup() + &quot; persistConsumerOffset exception&quot;, e);</span>
<span class="nc" id="L1023">        }</span>
<span class="nc" id="L1024">    }</span>

    @Override
    public void updateTopicSubscribeInfo(String topic, Set&lt;MessageQueue&gt; info) {
<span class="nc" id="L1028">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc" id="L1031">                this.rebalanceImpl.topicSubscribeInfoTable.put(topic, info);</span>
            }
        }
<span class="nc" id="L1034">    }</span>

    @Override
    public boolean isSubscribeTopicNeedUpdate(String topic) {
<span class="nc" id="L1038">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);</span>
            }
        }

<span class="nc" id="L1045">        return false;</span>
    }

    @Override
    public boolean isUnitMode() {
<span class="nc" id="L1050">        return this.defaultMQPushConsumer.isUnitMode();</span>
    }

    @Override
    public ConsumerRunningInfo consumerRunningInfo() {
<span class="nc" id="L1055">        ConsumerRunningInfo info = new ConsumerRunningInfo();</span>

<span class="nc" id="L1057">        Properties prop = MixAll.object2Properties(this.defaultMQPushConsumer);</span>

<span class="nc" id="L1059">        prop.put(ConsumerRunningInfo.PROP_CONSUME_ORDERLY, String.valueOf(this.consumeOrderly));</span>
<span class="nc" id="L1060">        prop.put(ConsumerRunningInfo.PROP_THREADPOOL_CORE_SIZE, String.valueOf(this.consumeMessageService.getCorePoolSize()));</span>
<span class="nc" id="L1061">        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));</span>

<span class="nc" id="L1063">        info.setProperties(prop);</span>

<span class="nc" id="L1065">        Set&lt;SubscriptionData&gt; subSet = this.subscriptions();</span>
<span class="nc" id="L1066">        info.getSubscriptionSet().addAll(subSet);</span>

<span class="nc" id="L1068">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = this.rebalanceImpl.getProcessQueueTable().entrySet().iterator();</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1070">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L1071">            MessageQueue mq = next.getKey();</span>
<span class="nc" id="L1072">            ProcessQueue pq = next.getValue();</span>

<span class="nc" id="L1074">            ProcessQueueInfo pqinfo = new ProcessQueueInfo();</span>
<span class="nc" id="L1075">            pqinfo.setCommitOffset(this.offsetStore.readOffset(mq, ReadOffsetType.MEMORY_FIRST_THEN_STORE));</span>
<span class="nc" id="L1076">            pq.fillProcessQueueInfo(pqinfo);</span>
<span class="nc" id="L1077">            info.getMqTable().put(mq, pqinfo);</span>
<span class="nc" id="L1078">        }</span>

<span class="nc bnc" id="L1080" title="All 2 branches missed.">        for (SubscriptionData sd : subSet) {</span>
<span class="nc" id="L1081">            ConsumeStatus consumeStatus = this.mQClientFactory.getConsumerStatsManager().consumeStatus(this.groupName(), sd.getTopic());</span>
<span class="nc" id="L1082">            info.getStatusTable().put(sd.getTopic(), consumeStatus);</span>
<span class="nc" id="L1083">        }</span>

<span class="nc" id="L1085">        return info;</span>
    }

    public MQClientInstance getmQClientFactory() {
<span class="nc" id="L1089">        return mQClientFactory;</span>
    }

    public void setmQClientFactory(MQClientInstance mQClientFactory) {
<span class="nc" id="L1093">        this.mQClientFactory = mQClientFactory;</span>
<span class="nc" id="L1094">    }</span>

    public ServiceState getServiceState() {
<span class="nc" id="L1097">        return serviceState;</span>
    }

    //Don't use this deprecated setter, which will be removed soon.
    @Deprecated
    public synchronized void setServiceState(ServiceState serviceState) {
<span class="nc" id="L1103">        this.serviceState = serviceState;</span>
<span class="nc" id="L1104">    }</span>

    public void adjustThreadPool() {
<span class="nc" id="L1107">        long computeAccTotal = this.computeAccumulationTotal();</span>
<span class="nc" id="L1108">        long adjustThreadPoolNumsThreshold = this.defaultMQPushConsumer.getAdjustThreadPoolNumsThreshold();</span>

<span class="nc" id="L1110">        long incThreshold = (long) (adjustThreadPoolNumsThreshold * 1.0);</span>

<span class="nc" id="L1112">        long decThreshold = (long) (adjustThreadPoolNumsThreshold * 0.8);</span>

<span class="nc bnc" id="L1114" title="All 2 branches missed.">        if (computeAccTotal &gt;= incThreshold) {</span>
<span class="nc" id="L1115">            this.consumeMessageService.incCorePoolSize();</span>
        }

<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (computeAccTotal &lt; decThreshold) {</span>
<span class="nc" id="L1119">            this.consumeMessageService.decCorePoolSize();</span>
        }
<span class="nc" id="L1121">    }</span>

    private long computeAccumulationTotal() {
<span class="nc" id="L1124">        long msgAccTotal = 0;</span>
<span class="nc" id="L1125">        ConcurrentMap&lt;MessageQueue, ProcessQueue&gt; processQueueTable = this.rebalanceImpl.getProcessQueueTable();</span>
<span class="nc" id="L1126">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = processQueueTable.entrySet().iterator();</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1128">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L1129">            ProcessQueue value = next.getValue();</span>
<span class="nc" id="L1130">            msgAccTotal += value.getMsgAccCnt();</span>
<span class="nc" id="L1131">        }</span>

<span class="nc" id="L1133">        return msgAccTotal;</span>
    }

    public List&lt;QueueTimeSpan&gt; queryConsumeTimeSpan(final String topic)
        throws RemotingException, MQClientException, InterruptedException, MQBrokerException {
<span class="nc" id="L1138">        List&lt;QueueTimeSpan&gt; queueTimeSpan = new ArrayList&lt;QueueTimeSpan&gt;();</span>
<span class="nc" id="L1139">        TopicRouteData routeData = this.mQClientFactory.getMQClientAPIImpl().getTopicRouteInfoFromNameServer(topic, 3000);</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        for (BrokerData brokerData : routeData.getBrokerDatas()) {</span>
<span class="nc" id="L1141">            String addr = brokerData.selectBrokerAddr();</span>
<span class="nc" id="L1142">            queueTimeSpan.addAll(this.mQClientFactory.getMQClientAPIImpl().queryConsumeTimeSpan(addr, topic, groupName(), 3000));</span>
<span class="nc" id="L1143">        }</span>

<span class="nc" id="L1145">        return queueTimeSpan;</span>
    }

    public void resetRetryAndNamespace(final List&lt;MessageExt&gt; msgs, String consumerGroup) {
<span class="nc" id="L1149">        final String groupTopic = MixAll.getRetryTopic(consumerGroup);</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        for (MessageExt msg : msgs) {</span>
<span class="nc" id="L1151">            String retryTopic = msg.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span>
<span class="nc bnc" id="L1152" title="All 4 branches missed.">            if (retryTopic != null &amp;&amp; groupTopic.equals(msg.getTopic())) {</span>
<span class="nc" id="L1153">                msg.setTopic(retryTopic);</span>
            }

<span class="nc bnc" id="L1156" title="All 2 branches missed.">            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {</span>
<span class="nc" id="L1157">                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));</span>
            }
<span class="nc" id="L1159">        }</span>
<span class="nc" id="L1160">    }</span>

    public ConsumeMessageService getConsumeMessageService() {
<span class="nc" id="L1163">        return consumeMessageService;</span>
    }

    public void setConsumeMessageService(ConsumeMessageService consumeMessageService) {
<span class="nc" id="L1167">        this.consumeMessageService = consumeMessageService;</span>

<span class="nc" id="L1169">    }</span>

    public void setPullTimeDelayMillsWhenException(long pullTimeDelayMillsWhenException) {
<span class="nc" id="L1172">        this.pullTimeDelayMillsWhenException = pullTimeDelayMillsWhenException;</span>
<span class="nc" id="L1173">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>